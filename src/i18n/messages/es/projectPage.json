{
	"backToProjects": "Volver a proyectos",
	"visitProject": "Visitar proyecto",
	"role": "Rol",
	"period": "Período",
	"status": "Estado",
	"client": "Cliente",
	"overview": {
		"title": "Visión General",
		"context": "Contexto",
		"solution": "Solución",
		"myRole": "Mi Rol"
	},
	"stack": {
		"title": "Stack Técnico",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Funcionalidades"
	},
	"challenges": {
		"title": "Desafíos & Soluciones"
	},
	"metrics": {
		"title": "Métricas",
		"linesOfCode": "Líneas de Código",
		"files": "Archivos",
		"modules": "Módulos",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Componentes",
		"hooks": "Hooks",
		"pages": "Páginas"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Decisiones Técnicas",
		"decision": "Decisión",
		"reason": "Justificación"
	},
	"testing": {
		"title": "Estrategia de Testing",
		"type": "Tipo",
		"tools": "Herramientas",
		"coverage": "Cobertura"
	},
	"gallery": {
		"title": "Galería"
	},
	"subProjects": "Proyectos",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Ecosistema de IA para el Sector de Construcción",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Abril 2025 - Actual",
			"status": "En Producción",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse es una startup francesa que revoluciona el sector de construcción y renovación energética a través de IA Generativa. El problema: los profesionales de la construcción necesitan verificar el cumplimiento de más de 300 regulaciones técnicas francesas (DTU, normas NF, Eurocodes, etc.), un proceso manual que consume tiempo y es propenso a errores. La solución: un asistente de IA entrenado específicamente en estas regulaciones, respondiendo preguntas técnicas instantáneamente citando las fuentes oficiales.",
				"solution": "El ecosistema consiste en tres componentes internos para que el equipo La Bonne Réponse gestione sus clientes: (1) LBR-API - API REST multi-tenant robusta que gestiona widgets de chat, autenticación doble (usuarios y widgets), integraciones con Stripe/AWS/Brevo, y control de calidad automatizado; (2) IA Factory - Back Office Admin donde el equipo configura chatbots, genera widgets personalizados, gestiona bases de conocimiento y monitorea conversaciones; (3) Portal Usuario - donde los profesionales de la construcción acceden al asistente de IA con historial de conversaciones y gestión de suscripciones. El enlace externo dirige al sitio institucional de la empresa.",
				"myRole": "Actué como Lead Front End y UI/UX Designer, siendo responsable de toda la arquitectura y desarrollo front-end de ambas plataformas (BO y Portal). Creé todo el diseño de interfaz y experiencia de usuario, tomé decisiones técnicas sobre stack y patrones de código. También colaboré activamente en el desarrollo de la API backend junto al equipo House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Herramienta RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robusta creada por el equipo House of Coding usando NestJS, especializada en gestión de widgets de chat con IA. Colaboré implementando las llamadas del dashboard, integración con herramienta RAG y upload de documentos en S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Integración RAG", "description": "Conexión con herramienta de Retrieval-Augmented Generation para respuestas basadas en documentos"},
							{"name": "Multi-Tenancy", "description": "Aislamiento completo de datos por tenant con JWT validado"},
							{"name": "Autenticación Doble", "description": "JWT separado para usuarios (admin, portal) y widgets embebidos"},
							{"name": "CORS Dinámico", "description": "Validación de origen basada en widget integrations en base de datos"},
							{"name": "Gestión de Widgets", "description": "Configuraciones visuales (4 colores), logo, mensajes, Google Analytics"},
							{"name": "Sistema de Referencias", "description": "Upload de documentos, URLs permitidas/bloqueadas, crawling automático"},
							{"name": "Control de Calidad", "description": "Puntos de verificación con preguntas/respuestas, validación automática vía IA"},
							{"name": "Integración Stripe", "description": "Webhooks con validación de firma, gestión de clientes por tenant"},
							{"name": "Upload S3", "description": "URLs prefirmadas para descarga segura con límite de tamaño"},
							{"name": "Rate Limiting", "description": "Throttler personalizado con 100 req/min por IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importación en lote de usuarios con validación y transaction"},
							{"name": "Swagger Automático", "description": "Documentación OpenAPI generada vía decoradores NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "Repositories TypeORM para abstracción de acceso a datos"},
						{"name": "DTO Pattern", "description": "101 DTOs con class-validator para validación de entrada"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard para control de acceso"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext para inyección de contexto"},
						{"name": "Service Layer", "description": "Lógica de negocio aislada de los controllers"},
						{"name": "Module Pattern", "description": "37 módulos NestJS para organización de features"}
					],
					"decisions": [
						{"decision": "Herramienta RAG", "reason": "Sistema para Retrieval-Augmented Generation, elegido por la flexibilidad y control sobre el pipeline de IA"},
						{"decision": "JWT Doble (Usuarios + Widgets)", "reason": "Widgets embebidos en sitios externos necesitan autenticación propia sin exponer credenciales de usuarios"},
						{"decision": "CORS Dinámico vía Base de Datos", "reason": "Cada widget puede embeberse en múltiples dominios, imposible configurar CORS estático"},
						{"decision": "URLs Prefirmadas para S3", "reason": "Descargas seguras sin exponer credenciales AWS, expiración configurable"},
						{"decision": "TypeORM en vez de Prisma", "reason": "Mejor integración con NestJS, soporte de decoradores, rendimiento para queries complejas"}
					],
					"challenges": [
						{"challenge": "CORS Dinámico para Widgets", "solution": "Query en base de datos para validar origen en cada request, caché en memoria para rendimiento"},
						{"challenge": "Webhook Stripe con Raw Body", "solution": "Middleware personalizado para preservar raw body antes del bodyParser de NestJS"},
						{"challenge": "Import en Lote de Usuarios", "solution": "Parsing CSV/Excel con fast-csv, validación en lote, insert con transaction y rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plataforma de Gestión de Chatbots IA",
					"description": "Dashboard administrativo enterprise-grade. Creé el diseño UI/UX, design system y toda la arquitectura de componentes. Desarrollé formularios multi-paso, tablas avanzadas, gestión de widgets, sistema de referencias y todas las demás funcionalidades excepto módulos de usuarios, empresas y QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administrativo", "description": "Interfaz completa para gestión de la plataforma con métricas"},
							{"name": "Formulario Multi-Paso", "description": "Creación de widget en 7 pasos con validación Zod por paso"},
							{"name": "Editor por Secciones", "description": "Accordion con secciones guardables independientemente vía PATCH"},
							{"name": "Widget Configurator", "description": "Preview en tiempo real de las personalizaciones del chatbot"},
							{"name": "DataTable Compuesta", "description": "Tablas con TanStack Table: ordenación, filtros, paginación, selección batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documentos con react-dropzone"},
							{"name": "Sistema de QC", "description": "Control de calidad con import CSV/Excel de puntos de verificación"},
							{"name": "Click Prompts Editor", "description": "Interfaz para crear prompts pre-configurados clicables"},
							{"name": "Gestión Multi-tenant", "description": "Administración de usuarios, empresas y permisos por rol"},
							{"name": "Sistema de Referentials", "description": "Monitoreo de crawler con última ejecución y detección de cambios"},
							{"name": "Cache Invalidation", "description": "Función central que invalida queries relacionadas en cascada"},
							{"name": "Historial de Conversaciones", "description": "Visualización de conversaciones de usuarios con renderizado markdown"},
							{"name": "Internacionalización", "description": "Sistema multi-idioma con react-i18next para soporte de diferentes idiomas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals como composiciones de sub-componentes"},
						{"name": "Custom Hooks", "description": "~40 hooks para lógica reutilizable (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextos para estado global de formularios multi-paso"},
						{"name": "Optimistic Updates", "description": "React Query con mutaciones optimistas para UX reactiva"},
						{"name": "Adapter Pattern", "description": "Transformación de datos API hacia formato UI"},
						{"name": "Feature-based Structure", "description": "Organización por features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context para estado UI (formularios), React Query para estado servidor"},
						{"decision": "Accordion para edición", "reason": "Permite guardar secciones independientemente sin bloquear al usuario"}
					],
					"challenges": [
						{"challenge": "Formulario de 7 Pasos", "solution": "Context para estado global, validación Zod por paso, hasStepErrors() para feedback visual"},
						{"challenge": "Upload con Preview", "solution": "FileReader para preview local inmediato, estado separado para preview vs saved"},
						{"challenge": "Edición por Secciones", "solution": "Accordion con botón Save por sección, PATCH para updates parciales, track changes"},
						{"challenge": "Cache Invalidation en Cascada", "solution": "Función refetchAllWidgetData() invalidando queries relacionadas en orden correcto"}
					]
				},
				{
					"title": "Portal Usuario",
					"subtitle": "Portal Web con Widget de Chat Integrado",
					"description": "Aplicación completa construida desde cero. Implementé autenticación robusta, refresh automático de tokens, integración Stripe, widget de chat en iframe aislado y refactorización completa de la versión Webflow.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10 minutos antes de expiración, reprogramación continua"},
							{"name": "Widget en Iframe", "description": "Aislamiento completo CSS/JS con sandbox, comunicación vía postMessage"},
							{"name": "Integración Stripe", "description": "Pricing table embebida, verificación de estado, billing portal"},
							{"name": "Sistema de Autenticación", "description": "Login, registro, activación de cuenta, reset de contraseña con tokens"},
							{"name": "Soporte B2B y B2C", "description": "Lógica de suscripción diferenciada por tipo de tenant"},
							{"name": "Gestión de Conversaciones", "description": "Sidebar con lista de conversaciones, crear nueva, continuar existente"},
							{"name": "Páginas de Presentación", "description": "URLs dinámicas por nombre para demos sin autenticación"},
							{"name": "Gestión de Cuenta", "description": "Editar perfil, título profesional, sector, cambiar contraseña con validación robusta"},
							{"name": "Internacionalización", "description": "Sistema multi-idioma con react-i18next para soporte de diferentes idiomas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Decodificación JWT + setTimeout para refresh proactivo"},
						{"name": "Iframe Isolation", "description": "Widget en sandbox con comunicación vía postMessage"},
						{"name": "Route Guards", "description": "Protección de rutas con verificación de autenticación y suscripción"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations para lógica encapsulada"}
					],
					"decisions": [
						{"decision": "Iframe para Widget", "reason": "Aislamiento completo CSS/JS, evita conflictos de estilo con el portal"},
						{"decision": "Refresh Proactivo", "reason": "Refresh 10min antes evita expiración durante uso activo"},
						{"decision": "Stripe Pricing Table", "reason": "Componente embebido elimina necesidad de UI personalizada para planes"},
						{"decision": "B2B sin pago", "reason": "Empresas B2B tienen contrato directo, no necesitan checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automático", "solution": "Decodificar JWT para obtener expiración, setTimeout 10min antes, reprogramar tras éxito"},
						{"challenge": "Widget en Iframe Aislado", "solution": "Sandbox con allow-scripts allow-same-origin, parámetros vía query string, postMessage"},
						{"challenge": "Estado de Suscripción", "solution": "Hook useSubscription() con lógica centralizada para B2B (sin pago) y B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Ecosistema Multi-Plataforma", "solution": "Arquitectura modular con API compartida entre BO y Portal, permitiendo evolución independiente de cada aplicación"},
				{"challenge": "Autenticación para Contextos Diferentes", "solution": "Sistema JWT doble: uno para usuarios autenticados (admin/portal) y otro para widgets embebidos en sitios externos"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plataformas de Formación Profesional",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Marzo 2025 - Actual",
			"status": "En Producción",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs es un organismo de formación profesional francés que acompaña a los aprendices en su trayectoria de desarrollo. Cada aprendiz es acompañado por un tutor que valida sus misiones y etapas de aprendizaje. El problema: seguimiento pedagógico fragmentado en hojas de cálculo y emails, sin trazabilidad centralizada del progreso, evaluaciones manuales dispersas (PIX, Cléa, soft skills), y comunicación tutor-aprendiz sin historial organizado.",
				"solution": "El ecosistema consiste en dos plataformas complementarias: (1) LINK-Parcours - Dashboard administrativo enterprise-grade para gestión de sesiones de formación, usuarios con 8 niveles de roles, evaluaciones de posicionamiento (PIX, Cléa, soft skills), y seguimiento de progreso (béabas, missions); (2) Tuto-Mission - PWA mobile-first para acompañamiento pedagógico en tiempo real, donde los tutores monitorean aprendices a través de chat con soporte de media y validación de etapas.",
				"myRole": "En LINK-Parcours, actué como Lead Front End y UI/UX Designer, creando todo el diseño de la interfaz administrativa e implementando el sistema completo. En Tuto-Mission, implementé el diseño recibido via Figma de House of Coding, desarrollando estrategias de cache avanzadas para compensar API legacy y crear una experiencia fluida."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (equipo House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administrativo de Formación",
					"description": "Plataforma administrativa completa para gestión de sesiones de formación, usuarios y evaluaciones. Creé todo el diseño UI/UX e implementé el sistema con control de acceso basado en 8 niveles de roles, tablas paginadas server-side, y formularios complejos con validación i18n.",
					"features": {
						"frontend": [
							{"name": "Gestión de Usuarios", "description": "CRUD completo con 8 niveles de roles (superAdmin hasta aprendiz)"},
							{"name": "Gestión de Sesiones", "description": "Creación de sesiones con múltiples días (session_jours) y participantes"},
							{"name": "Evaluación de Posicionamiento", "description": "Scores PIX, resultados Cléa, soft skills games, entrevistas"},
							{"name": "Seguimiento de Progreso", "description": "Béabas y missions con cálculo de porcentaje global"},
							{"name": "Tablas Avanzadas", "description": "TanStack Table con ordenación, filtros, paginación server-side"},
							{"name": "URL State Management", "description": "Filtros persistidos en URL via nuqs para compartir"},
							{"name": "Formularios Validados", "description": "React Hook Form + Zod con mensajes i18n en francés"},
							{"name": "Upload de Foto", "description": "Drag & drop con preview y gestión de perfil"},
							{"name": "Dashboard con Gráficos", "description": "Visualizaciones con Recharts para métricas"},
							{"name": "Sistema de Roles", "description": "RoleProtectedRoute + useRoleBasedRedirect para control de acceso"},
							{"name": "Pre-inscripciones", "description": "Gestión de candidatos por sesión de formación"},
							{"name": "Internacionalización", "description": "Sistema multi-idioma con react-i18next para soporte de diferentes idiomas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 niveles jerárquicos con RoleProtectedRoute y redirección automática"},
						{"name": "Container/Presenter", "description": "Hooks de datos separados de componentes de tabla"},
						{"name": "URL State Management", "description": "nuqs sincroniza filtros/paginación con query parameters"},
						{"name": "Schema Validation", "description": "Zod dinámico con traducciones i18n para mensajes de error"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI con class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adaptan estructura API al formato UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Productividad aumentada, design system integrado, purge automático"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives accesibles sin styling impuesto, control total sobre apariencia"},
						{"decision": "nuqs para URL state", "reason": "Sincronización bidireccional automática, type-safe con parsers"},
						{"decision": "Paginación Híbrida", "reason": "Server-side para users/sessions (gran volumen), client-side para aprendices (filtrado rápido)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (menos re-renders), integración nativa, mejor TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Niveles de Roles", "solution": "Enum UserGroupCode con códigos numéricos jerárquicos, matriz de permisos por ruta"},
						{"challenge": "Filtros Persistentes", "solution": "Estado en URL via nuqs + location.state para contexto de navegación"},
						{"challenge": "Sistema de Posicionamiento", "solution": "Componentes dedicados por tipo (PIX, Cléa, soft skills) + hook usePositioning centralizado"},
						{"challenge": "Formularios Multi-Etapas", "solution": "Tabs organizando secciones, schema Zod parcial por sección, validación en submit"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA de Acompañamiento Pedagógico",
					"description": "Aplicación mobile-first para acompañamiento pedagógico en tiempo real. Implementé el diseño recibido via Figma, desarrollando sistema de chat con soporte de media, validación de etapas, y estrategia de cache sofisticada para compensar API legacy.",
					"features": {
						"frontend": [
							{"name": "Sistema de Chat", "description": "Mensajes en tiempo real tutor ↔ aprendiz con historial persistente"},
							{"name": "Upload de Media", "description": "Fotos y videos pedagógicos con preview antes del envío"},
							{"name": "Validación de Etapas", "description": "Tutor valida o solicita rehacerlo con feedback visual inmediato"},
							{"name": "Videos con Timestamps", "description": "Player React Player con timestamps específicos por etapa"},
							{"name": "Auto-scroll Inteligente", "description": "Hook useScrollToBottom observa cambios y ejecuta scroll"},
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10min antes de expiración, transparente al usuario"},
							{"name": "Múltiples Aprendices", "description": "Selección automática si tutor tiene 1, página de selección si N"},
							{"name": "Mensajes de Pedagogía", "description": "Mensajes automáticos del sistema con estilización diferenciada"},
							{"name": "Optimistic Updates", "description": "Mensajes aparecen instantáneamente antes de confirmación del servidor"},
							{"name": "Cache Performático", "description": "Stale-while-revalidate para navegación zero-latency"},
							{"name": "Internacionalización", "description": "Sistema multi-idioma con react-i18next para soporte de diferentes idiomas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centraliza lógica de autenticación con variables globales"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulan lógica de datos"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo por tipo de mensaje"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observa dependencias para auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrappea requests con JWT y retry de token"},
						{"name": "Optimistic Updates", "description": "React Query con mutaciones optimistas y rollback automático"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automático, mutations con optimistic updates, menos boilerplate"},
						{"decision": "CSS Puro", "reason": "Proyecto mobile-first pequeño, performance sin runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT en cookie para seguridad, datos de usuario en localStorage para acceso rápido"},
						{"decision": "Upload Directo via API", "reason": "Arquitectura más simple, backend controla validaciones"}
					],
					"challenges": [
						{"challenge": "API Legacy Lenta", "solution": "Cache sofisticado: staleTime 5-10min, gcTime 30min, placeholderData para UX instantánea"},
						{"challenge": "Refresh de Token Transparente", "solution": "Timer 10min antes de expiración + handleTokenExpiration global para errores 401"},
						{"challenge": "Upload con Preview", "solution": "URL.createObjectURL() para preview local, envío separado de texto y media"},
						{"challenge": "Scroll Automático en Chat", "solution": "Hook customizado observa [messages, isLoading] y ejecuta scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Dos Plataformas Complementarias", "solution": "Arquitectura consistente con React Query en ambas, patterns reutilizables"},
				{"challenge": "API PHP Legacy Compartida", "solution": "Estrategias de cache en frontend para crear experiencia premium sin modificar backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Capa de Abstracción para Dispositivos IoT",
			"role": "Backend Developer",
			"period": "Noviembre 2024 - Actual",
			"status": "En Desarrollo",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell es una empresa de climatización que ofrece dispositivos IoT (aire acondicionado, termostatos, sensores) controlados vía aplicación móvil. Para conectar dispositivos de múltiples fabricantes, la empresa utilizaba un servicio tercerizado como intermediario. El problema: costos recurrentes de licencia por dispositivo, vendor lock-in, latencia adicional, e imposibilidad de customizar sin depender del proveedor.",
				"solution": "Actualmente la empresa utiliza una API externa tercerizada para conectar los dispositivos, generando altos costos mensuales. El IoT Router es una capa de abstracción que conecta directamente a las APIs de los fabricantes de dispositivos, normaliza los diferentes formatos en una API unificada, mantiene compatibilidad con el formato esperado por el mobile legacy, y escala para soportar nuevos fabricantes vía sistema de plugins. La solución eliminará estos costos y dará independencia tecnológica total a la empresa.",
				"myRole": "Asumí un proyecto iniciado por un colega de Amiltone y realicé una refactorización masiva, definiendo buenas prácticas y adaptando la arquitectura para escalar. Diseñé la arquitectura de plugins para múltiples fabricantes, desarrollé sistema de rate limiting distribuido con Redis, e integré AWS Lambda para comandos programados. También hice intervenciones en la API server estándar de Airwell para integrar el IoT Router, y realicé debugging completo de la app mobile React Native que no funcionaba - identificando problemas y enviando informes al equipo."
			},
			"stack": {
				"frontend": ["React Native (debugging + informes para equipo Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Sistema de Plugins Multi-Fabricante + Comandos Programados",
					"description": "Capa de abstracción con arquitectura de plugins para integración con múltiples fabricantes IoT. Cada fabricante es un módulo aislado que implementa una interfaz común. Incluye sistema de comandos programados vía AWS Lambda + Bull Queue con retry automático.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Sistema extensible donde cada fabricante es un plugin aislado implementando IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Descubrimiento automático de dispositivos por usuario y fabricante con extracción de metadatos"},
							{"name": "Data Handler", "description": "Lectura de status, mediciones (temperatura, humedad, CO2) con normalización de unidades"},
							{"name": "Command Handler", "description": "Ejecución de comandos (encender/apagar, ajustar temperatura) con retry automático"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue para comandos programados con retry exponencial"},
							{"name": "OAuth 2.0 Flow", "description": "Flujo de autenticación completo con refresh automático de tokens cifrados"},
							{"name": "Rate Limiting", "description": "Algoritmo sliding window en Redis con reglas customizadas por fabricante"},
							{"name": "Adapter Pattern", "description": "Transformación de datos del formato fabricante hacia formato normalizado compatible con mobile"},
							{"name": "Configuration as Code", "description": "Configuración de socios y dispositivos vía YAML validado por JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulando acceso a datos con queries optimizadas"},
							{"name": "Interceptors & Guards", "description": "Logging estructurado y manejo de errores consistente en toda la aplicación"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricantes como módulos aislados implementando interfaz común (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separación de responsabilidades: handlers Discovery, Data y Command especializados"},
						{"name": "Strategy Pattern", "description": "Cada plugin implementa su propia estrategia de autenticación (OAuth, API Key, propietaria)"},
						{"name": "Adapter Pattern", "description": "Normalización de datos heterogéneos hacia formato único compatible con mobile legacy"},
						{"name": "Queue Pattern", "description": "Bull Queue para comandos programados con desacoplamiento trigger/ejecución"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulando acceso a datos con queries centralizadas"},
						{"name": "Factory Pattern", "description": "Rate limit calculators específicos por fabricante con reglas customizadas"},
						{"name": "Decorator Pattern", "description": "Interceptors y filters decorando operaciones con logging y error handling"}
					],
					"decisions": [
						{"decision": "Redis para Rate Limiting", "reason": "Distribuido, persistente, sliding window preciso, reutilizado para colas Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Ya tenemos Redis, UI de monitoreo (Bull Board), menos latencia que SQS"},
						{"decision": "AES-256-GCM en Base", "reason": "Simplicidad operacional vs Vault dedicado, suficiente para el caso de uso"}
					],
					"challenges": [
						{"challenge": "APIs Heterogéneas", "solution": "Plugin pattern aísla complejidad - cada plugin habla el 'idioma' del fabricante"},
						{"challenge": "Rate Limiting Complejo", "solution": "Configuración por fabricante + sliding window Redis + métricas para ajuste fino"},
						{"challenge": "Compatibilidad Mobile Legacy", "solution": "Adapter pattern normaliza respuestas al formato esperado por la app antigua"},
						{"challenge": "Comandos Programados", "solution": "AWS EventBridge → Lambda → Bull Queue con retry exponencial y auditoría"}
					]
				}
			],
			"challenges": [
				{"challenge": "Código Mobile Legacy Problemático (Mayor Desafío)", "solution": "Nada funcionaba - código sucio, sin patrones, errores en cascada. Realicé debugging completo identificando 73 errores críticos, refactoricé el backend para normalizar datos y minimizar intervenciones en el frontend legacy caótico"},
				{"challenge": "Reemplazar Servicio Tercerizado", "solution": "Arquitectura de plugins permitió integración directa con fabricantes manteniendo compatibilidad mobile"}
			]
		},
		"ragboost": {
			"title": "Ragboost",
			"subtitle": "Plataforma SaaS Multi-Tenant de Chatbots IA",
			"role": "Full Stack Developer | Fundador",
			"period": "Octubre 2024 - Presente",
			"status": "En Desarrollo (85%)",
			"client": "Proyecto Propio",
			"overview": {
				"context": "El mercado de chatbots IA está creciendo, pero las soluciones empresariales son caras para las PyMEs. Las empresas enfrentan altos costos por mensaje y almacenamiento, complejidad técnica para integrar RAG, widgets genéricos que no representan la marca, falta de colaboración en equipo, y datos aislados que no se aprovechan. La oportunidad: crear una alternativa accesible con características avanzadas para empresas de todos los tamaños.",
				"solution": "Desarrollo de una plataforma SaaS completa que democratiza el acceso a chatbots IA con precios accesibles, simplifica la creación de asistentes sin código, escala con arquitectura multi-tenant robusta, y monetiza con planes flexibles vía Stripe. La plataforma permite que empresas creen asistentes virtuales contextualizados con sus propios documentos usando tecnología RAG (Retrieval-Augmented Generation), con sistema de colaboración en equipo con RBAC completo y soporte para 4 idiomas.",
				"myRole": "Como fundador y desarrollador full stack, diseñé e implementé toda la arquitectura del sistema. En el backend, desarrollé Clean Architecture con Either Monad, Use Case Pattern y Domain Events. En el frontend, implementé TanStack Query con Optimistic Updates, sistema de autenticación cross-subdomain, y enrutamiento file-based con TanStack Router. También hice todo el diseño UI/UX y las integraciones con Stripe, servicio RAG open source, y sistema de emails."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "TanStack Router", "TanStack Query", "Tailwind CSS", "shadcn/ui", "Radix UI", "React Hook Form", "Zod", "i18next", "Recharts", "Axios", "Sonner", "Lucide React"],
				"backend": ["Fastify", "TypeScript", "Prisma", "PostgreSQL", "JWT", "bcryptjs", "Stripe", "Nodemailer", "Swagger", "Zod"]
			},
			"subProjects": [
				{
					"title": "Backend API",
					"subtitle": "API REST Multi-Tenant con Clean Architecture",
					"description": "API REST robusta con arquitectura limpia, 10 módulos de dominio, sistema de permisos granular (RBAC) con 50+ permisos, integración con Stripe para billing, y Domain Events para comunicación entre módulos.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Clean Architecture", "description": "Separación en capas: routes → controllers → use-cases → repositories → entities"},
							{"name": "Either Monad", "description": "Tratamiento funcional de errores con Either<Error, Success> en todos los use cases"},
							{"name": "Multi-Tenancy", "description": "Aislamiento total de datos por tenant vía subdomain con middleware de contexto"},
							{"name": "RBAC Granular", "description": "50+ permisos en 4 niveles de roles (owner, admin, curator, user)"},
							{"name": "Domain Events", "description": "Comunicación asíncrona entre módulos para desacoplamiento"},
							{"name": "Webhook Service", "description": "Handlers para eventos Stripe (checkout, subscription, invoice) con verificación de firma"},
							{"name": "Factory Pattern", "description": "Inyección de dependencias manual sin container, fácil de testear y depurar"},
							{"name": "Zod + OpenAPI", "description": "Validación de schemas con generación automática de documentación Swagger"},
							{"name": "JWT Doble", "description": "Access token (15min) + refresh token (7d) en cookie httpOnly"},
							{"name": "Rate Limiting", "description": "Protección de endpoints con límites por IP y usuario"},
							{"name": "Integración RAG", "description": "Conexión con servicio open source para procesamiento de documentos y búsqueda semántica"},
							{"name": "Sistema de Invitaciones", "description": "Envío de invitaciones por email con tracking, expiración y roles asignables"},
							{"name": "Suscripción con Addons", "description": "Sistema flexible de planes Stripe con addons modulares (asientos extra, almacenamiento, llamadas API)"},
							{"name": "Billing Completo", "description": "Checkout sessions, portal de cliente, facturas, proration, períodos de prueba, cancelación"}
						]
					},
					"testing": [
						{"type": "Tests Unitarios", "description": "60+ archivos testeando use cases y domain logic con 18+ In-Memory Repositories y 7 In-Memory Providers (hash, token, email, ragflow, stripe, etc.)", "tools": "Node.js Test Runner, In-Memory Repositories/Providers", "coverage": "Use cases completos"},
						{"type": "Tests E2E", "description": "40+ archivos testeando controllers con Prisma Test Environment (base aislada), seed automático de planes, helpers para datos únicos (generateUniqueEmail, generateUniqueSlug)", "tools": "Node.js Test Runner, Prisma Test Environment, Supertest", "coverage": "Todas las rutas"}
					],
					"metrics": {
						"linesOfCode": "~52.000",
						"files": "200+",
						"modules": "10",
						"entities": "17"
					},
					"patterns": [
						{"name": "Either Monad Pattern", "description": "Either<L, R> con left() para errores y right() para éxito - errores type-safe"},
						{"name": "Use Case Pattern", "description": "Cada operación de negocio en clase aislada con execute() retornando Either"},
						{"name": "Factory Pattern", "description": "makeXxxUseCase() para DI manual - cero magia, tree-shakeable, debug fácil"},
						{"name": "Controller Pattern", "description": "HTTP handlers que convierten Either en status codes apropiados"},
						{"name": "Repository Pattern", "description": "Abstracción de acceso a datos con Prisma - in-memory para tests"},
						{"name": "Provider Pattern", "description": "Servicios externos (email, payment, RAG) con interface + implementación"}
					],
					"decisions": [
						{"decision": "Fastify vs Express vs NestJS", "reason": "2x más rápido que Express, validación de schema nativa, sistema de plugins modular"},
						{"decision": "Either Monad vs throw/catch", "reason": "Errores type-safe, flujo explícito, controller sabe exactamente qué errores esperar"},
						{"decision": "Factory Pattern vs DI Container", "reason": "Cero magia, tree-shakeable, TypeScript puro sin decorators, fácil de testear"},
						{"decision": "PostgreSQL + Prisma vs MongoDB", "reason": "Cumplimiento ACID, relaciones complejas, type-safety, migrations, RLS nativo"}
					],
					"challenges": [
						{"challenge": "Aislamiento Multi-Tenant", "solution": "Middleware inyecta contexto del tenant en todas las queries vía header X-Tenant-Subdomain"},
						{"challenge": "50+ Permisos Granulares", "solution": "Matriz roles → permissions, CheckPermissionUseCase reutilizado en todos los use cases"},
						{"challenge": "Webhook Stripe con Raw Body", "solution": "Middleware customizado para preservar raw body antes del bodyParser de Fastify"},
						{"challenge": "Tests E2E Aislados", "solution": "Prisma test environment con base aislada, helpers para generar datos únicos"}
					]
				},
				{
					"title": "Frontend Dashboard",
					"subtitle": "SPA React 19 con Multi-Tenant vía Subdomain",
					"description": "Dashboard administrativo SPA con React 19 y TanStack Router. Sistema de autenticación cross-subdomain vía cookies, cache sofisticado con TanStack Query, internacionalización en 4 idiomas, y 31 componentes shadcn/ui.",
					"features": {
						"frontend": [
							{"name": "Multi-Tenant vía Subdomain", "description": "Detección automática de tenant vía hostname (tenant1.ragboost.app)"},
							{"name": "Auth Cross-Subdomain", "description": "Cookies compartidas entre subdomains vía Domain=.ragboost.app"},
							{"name": "TanStack Query Cache", "description": "staleTime, gcTime, refetchOnMount/WindowFocus configurados por query"},
							{"name": "Optimistic Updates", "description": "onMutate → snapshot → rollback con feedback instantáneo"},
							{"name": "File-Based Routing", "description": "TanStack Router con type-safety completo y beforeLoad para guards"},
							{"name": "Axios Interceptors", "description": "Refresh token automático, retry con exponential backoff, error handling i18n"},
							{"name": "RBAC en Frontend", "description": "useCurrentUserRole() con canManageTeam, canEditChatbots, etc."},
							{"name": "Formularios Validados", "description": "React Hook Form + Zod con schemas compartidos frontend/backend"},
							{"name": "Design System", "description": "31 componentes shadcn/ui + Radix UI con Tailwind CSS 4"},
							{"name": "i18n Completo", "description": "4 idiomas (PT, EN, FR, ES) con namespaces lazy-loaded"},
							{"name": "Dashboard Analytics", "description": "Gráficos con Recharts para métricas de uso"},
							{"name": "Team Management", "description": "Invitaciones, roles, eliminación de miembros con optimistic updates"},
							{"name": "Gestión de Suscripción", "description": "Vista del plan actual, addons, uso, upgrade/downgrade con Stripe Customer Portal"},
							{"name": "Selector de Addons", "description": "Interfaz para agregar/quitar addons (asientos, almacenamiento, llamadas API) con preview de precio"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~19.500",
						"files": "206",
						"components": "88",
						"hooks": "7+",
						"pages": "15+"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "useChatbots, useTeamMembers, useAuth encapsulando lógica de datos"},
						{"name": "Optimistic Updates Pattern", "description": "onMutate para snapshot, onError para rollback, onSuccess para invalidate"},
						{"name": "Provider Pattern", "description": "AuthProvider, TenantProvider para estado global"},
						{"name": "API Queries Layer", "description": "Separación en /api/queries con barrel exports por feature"},
						{"name": "Subdomain Detection", "description": "getCurrentSubdomain() detecta tenant en dev (lvh.me) y prod"},
						{"name": "Interceptor Pattern", "description": "Axios interceptors para refresh token y retry automático"}
					],
					"decisions": [
						{"decision": "React 19 SPA vs Next.js", "reason": "Dashboard no necesita SSR, Vite HMR instantáneo, builds 10x más rápidos"},
						{"decision": "TanStack Query vs Redux", "reason": "Cache automático, mutations con optimistic updates, menos boilerplate"},
						{"decision": "TanStack Router vs React Router", "reason": "Type-safety completo, file-based routing, beforeLoad para guards"},
						{"decision": "Cookie Auth vs localStorage", "reason": "Compartir cross-subdomain imposible con localStorage"}
					],
					"challenges": [
						{"challenge": "Auth Cross-Subdomain", "solution": "Cookie con Domain=.localhost (dev) / .ragboost.app (prod) compartida entre tenants"},
						{"challenge": "Refresh Token Transparente", "solution": "Interceptor detecta 401, llama /refresh-token, reintenta request original"},
						{"challenge": "State Management Complejo", "solution": "TanStack Query para server state, useCurrentTenant() para contexto, cero Redux"},
						{"challenge": "Detección Subdomain Multi-Ambiente", "solution": "Soporte para lvh.me (dev), localhost, y multisaas.app (prod) con misma lógica"}
					]
				}
			],
			"challenges": [
				{"challenge": "Arquitectura SaaS Multi-Tenant Completa", "solution": "Tenancy basada en subdomain con aislamiento de datos, RBAC granular, billing integrado, y Domain Events para desacoplamiento"},
				{"challenge": "Auth Cross-Subdomain Segura", "solution": "JWT en cookies con Domain wildcard, refresh token automático, logout selectivo de cache"}
			]
		},
		"va-beauty": {
			"title": "VA Beauty",
			"subtitle": "Sitio Vitrina & Sistema de Reservas",
			"role": "Full Stack Developer | UI/UX Designer",
			"period": "Mayo - Agosto 2025",
			"status": "En Producción",
			"client": "VA Beauty",
			"overview": {
				"context": "VA Beauty es un instituto de belleza boutique en Aubagne, Francia, especializado en tratamientos faciales de alta calidad y micropigmentación. La propietaria necesitaba una presencia digital que reflejara la calidad premium de sus servicios. El problema: sin presencia online, citas manuales por teléfono/WhatsApp, sin portafolio visual para mostrar resultados, y gestión manual de servicios y precios.",
				"solution": "Desarrollo de un sitio vitrina profesional completo con: (1) Landing page premium con secciones de servicios, galería antes/después y testimonios; (2) Sistema de reservas integrado con Cal.com con calendario en tiempo real y pago Stripe; (3) Galería dinámica soportando imágenes, antes/después y videos de redes sociales; (4) Blog gestionado vía Sanity CMS para contenido de marketing; (5) Panel administrativo para gestión de servicios y galería sin conocimientos técnicos.",
				"myRole": "Trabajé como Full Stack Developer y UI/UX Designer, creando todo el diseño de interfaz desde cero e implementando la solución completa. Desarrollé la arquitectura con Next.js 15 y React 19, integré múltiples servicios externos (Supabase, Cal.com, Stripe, Cloudinary, Sanity), y construí el panel administrativo para gestión autónoma del contenido."
			},
			"stack": {
				"frontend": ["Next.js 15", "React 19", "TypeScript", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "Lucide React", "react-day-picker", "class-variance-authority"],
				"backend": ["Supabase (PostgreSQL + Auth + RLS)", "Stripe", "Cal.com", "Cloudinary", "Sanity CMS", "Vercel"]
			},
			"subProjects": [
				{
					"title": "Sitio Vitrina & Booking",
					"subtitle": "Plataforma Completa de Reservas Online",
					"description": "Sitio vitrina profesional con sistema de reservas integrado. Creé todo el diseño UI/UX e implementé landing page premium, catálogo de servicios, galería dinámica, blog, y flujo completo de reservas con pago.",
					"features": {
						"frontend": [
							{"name": "Landing Page Premium", "description": "Hero con degradado, indicadores de confianza (500+ clientes, 5★), secciones de servicios y testimonios"},
							{"name": "Catálogo de Servicios", "description": "Grid con 3 categorías (Sourcils, Lèvres, Soins), combos/paquetes con precios"},
							{"name": "Galería Antes/Después", "description": "Filtro por categoría, tipos de media (imágenes, antes/después, videos), modal pantalla completa"},
							{"name": "Flujo de Reserva Multi-Paso", "description": "4 pasos: selección de servicio → fecha/hora → información → confirmación/pago"},
							{"name": "Calendario Cal.com", "description": "Widget embebido con disponibilidad en tiempo real y timezone automático"},
							{"name": "Videos Embebidos", "description": "Soporte para Instagram, YouTube y TikTok con embed responsive"},
							{"name": "Blog Integrado", "description": "Artículos gestionados vía Sanity CMS con SEO optimizado"},
							{"name": "Diseño Responsive", "description": "Mobile-first con tipografía Sora y sistema de colores con degradados"}
						],
						"backend": [
							{"name": "Auth Supabase", "description": "Autenticación con verificación de admin vía tabla admin_accounts"},
							{"name": "Row Level Security", "description": "Políticas RLS para protección de datos PostgreSQL"},
							{"name": "Integración Stripe", "description": "Pagos con Connected Accounts y webhooks bidireccionales"},
							{"name": "Integración Cal.com", "description": "API para disponibilidad, creación de reservas y sincronización"},
							{"name": "Upload Cloudinary", "description": "Optimización automática de imágenes, transformaciones on-the-fly, CDN global"},
							{"name": "Sanity CMS", "description": "Studio personalizable para gestión de blog con queries GROQ"},
							{"name": "Rutas API Protegidas", "description": "Endpoints para booking, gallery, admin con validación y manejo de errores"},
							{"name": "Middleware de Protección", "description": "Next.js Middleware protegiendo rutas /admin y /studio"}
						]
					},
					"metrics": {
						"linesOfCode": "~30.135",
						"files": "188",
						"components": "57",
						"pages": "32 rutas API"
					},
					"patterns": [
						{"name": "App Router Pattern", "description": "Route groups, layouts anidados, loading states con Next.js 15"},
						{"name": "Server/Client Components", "description": "Server Components para data fetching, Client para interactividad"},
						{"name": "Multi-Step Form Pattern", "description": "Estado centralizado con pasos progresivos y validación por paso"},
						{"name": "Provider Pattern", "description": "AuthProvider + SupabaseProvider para estado global de autenticación"},
						{"name": "Middleware Protection", "description": "Verificación de admin en el edge antes de cargar páginas protegidas"},
						{"name": "API Route Pattern", "description": "Lógica backend aislada con validación y manejo de errores consistente"}
					],
					"decisions": [
						{"decision": "Next.js 15 + React 19", "reason": "Server Components para performance, App Router para organización, Turbopack para builds rápidos"},
						{"decision": "Supabase vs Firebase", "reason": "PostgreSQL real con SQL, Row Level Security nativo, auth integrado, open source, precios accesibles"},
						{"decision": "Cal.com vs Calendly", "reason": "Open source, API flexible, integración Stripe nativa, personalización completa, sin branding forzado"},
						{"decision": "Cloudinary vs S3", "reason": "Optimización automática de imágenes, transformaciones on-the-fly, CDN global incluido, tier gratuito generoso"},
						{"decision": "Sanity vs Contentful", "reason": "Studio personalizable, lenguaje de consulta GROQ poderoso, colaboración en tiempo real, tier gratuito generoso"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste no dependencia, personalización total, accesibilidad vía Radix, bundle más pequeño, Tailwind nativo"}
					],
					"challenges": [
						{"challenge": "Integración Cal.com + Stripe", "solution": "Stripe Connected Account, webhooks bidireccionales (Cal → App, Stripe → App), endpoints de diagnóstico para debug"},
						{"challenge": "Galería Multi-Media", "solution": "Schema flexible con type discriminator, componente MediaModal detectando tipo, embed de video responsive"},
						{"challenge": "Control de Acceso Admin", "solution": "Tabla admin_accounts con permisos JSONB, flag is_active, super-admin fallback, políticas RLS"},
						{"challenge": "SEO para Servicios Dinámicos", "solution": "generateMetadata en cada page, datos estructurados JSON-LD, sitemap dinámico, alt text requerido"},
						{"challenge": "Performance con Muchas Imágenes", "solution": "Next.js Image con lazy loading, Cloudinary para optimización, placeholder blur, sizes responsive"}
					]
				}
			],
			"challenges": [
				{"challenge": "Múltiples Integraciones Externas", "solution": "Arquitectura modular con providers separados para cada servicio (Supabase, Cal.com, Stripe, Cloudinary, Sanity), webhooks robustos con retry"},
				{"challenge": "Flujo de Reserva Complejo", "solution": "Formulario multi-paso con estado centralizado, validación progresiva, integración seamless entre Cal.com y Stripe"}
			]
		},
		"sncf-util-ia": {
			"title": "SNCF IA Reseau",
			"subtitle": "Plataforma de Asistencia Inteligente para Red Ferroviaria",
			"role": "Full Stack Developer",
			"period": "Octubre - Diciembre 2024",
			"status": "Producción",
			"client": "SNCF (Société Nationale des Chemins de fer Français)",
			"overview": {
				"context": "SNCF necesitaba una plataforma interna para optimizar el soporte a los empleados del área de Utilité, proporcionando respuestas instantáneas sobre procedimientos, regulaciones e información técnica de la red ferroviaria a través de inteligencia artificial.",
				"solution": "Sistema completo con API REST robusta en NestJS e interfaz web moderna en React. Integración con Chatbase AI para procesamiento de preguntas, sistema de autenticación JWT, y panel administrativo para gestión de usuarios y monitoreo de conversaciones.",
				"myRole": "Trabajé como desarrollador solo en el backend, creando toda la arquitectura de la API con NestJS, TypeORM y MySQL. En el frontend, trabajé junto con el equipo de diseño de House of Coding (que proporcionó el UI/UX vía Figma), siendo responsable de la implementación completa y las animaciones de la interfaz."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Tailwind CSS", "shadcn/ui", "Radix UI", "React Router DOM", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "Recharts", "Sonner", "Lucide React"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "Chatbase AI", "class-validator", "class-transformer", "bcrypt", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "SNCF IA Reseau API",
					"subtitle": "Backend NestJS para Gestión de Conversaciones y Usuarios",
					"description": "API REST robusta desarrollada en NestJS con arquitectura modular. Sistema completo de autenticación JWT, integración con Chatbase AI para procesamiento de preguntas, gestión de usuarios con diferentes niveles de permisos, y monitoreo de conversaciones.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Autenticación JWT", "description": "Sistema completo con register/login, refresh tokens, guards de protección y estrategia Passport"},
							{"name": "Integración Chatbase AI", "description": "Proxy para API de Chatbase con gestión de conversaciones, historial y rate limiting"},
							{"name": "Gestión de Usuarios", "description": "CRUD completo con perfiles (USER, ADMIN, SUPER_ADMIN), soft delete y validaciones robustas"},
							{"name": "Monitoreo de Conversaciones", "description": "Historial completo de conversaciones con filtros, paginación y estadísticas"},
							{"name": "API de Estadísticas", "description": "Dashboard con métricas de uso, conversaciones por período y análisis de usuarios activos"},
							{"name": "Logs Estructurados", "description": "Sistema de logging con Winston para debug y auditoría"},
							{"name": "Swagger/OpenAPI", "description": "Documentación automática e interactiva de la API con ejemplos"},
							{"name": "Docker Setup", "description": "Containerización completa con MySQL, volúmenes persistentes y red aislada"}
						]
					},
					"metrics": {
						"linesOfCode": "~8.500",
						"files": "67",
						"modules": "7",
						"entities": "3",
						"dtos": "15+"
					},
					"patterns": [
						{"name": "Modular Architecture", "description": "Separación en módulos (Auth, Users, Conversations, Stats, Chatbase) con responsabilidades bien definidas"},
						{"name": "Repository Pattern", "description": "TypeORM repositories para abstracción de acceso a datos"},
						{"name": "DTO Pattern", "description": "Data Transfer Objects con class-validator para validación de entrada/salida"},
						{"name": "Guard Pattern", "description": "Guards personalizados para autenticación JWT y verificación de roles"},
						{"name": "Exception Filters", "description": "Manejo centralizado de errores con HttpException"},
						{"name": "Dependency Injection", "description": "Inyección de dependencias nativa de NestJS para testabilidad"}
					],
					"decisions": [
						{"decision": "NestJS vs Express/Fastify", "reason": "Estructura enterprise-ready out-of-the-box, TypeScript first-class, arquitectura modular escalable, decorators para metaprogramación, integración Swagger nativa"},
						{"decision": "TypeORM vs Prisma", "reason": "Decorators para entities, migraciones robustas, soporte para múltiples bases de datos, patrón active record familiar, mejor para proyectos NestJS complejos"},
						{"decision": "JWT vs Session", "reason": "Stateless, escalable horizontalmente, no requiere almacenamiento server-side, ideal para APIs REST, refresh tokens para seguridad"},
						{"decision": "Chatbase vs OpenAI Direct", "reason": "Sistema de conversaciones gestionado, entrenamiento específico del modelo, rate limiting incluido, métricas integradas, costo optimizado"},
						{"decision": "Winston vs Console", "reason": "Logs estructurados, múltiples transports (archivo, consola), niveles configurables, rotación automática, esencial para producción"}
					],
					"challenges": [
						{"challenge": "Rate Limiting de Chatbase", "solution": "Implementación de cola de peticiones con retry exponencial, caché de respuestas frecuentes, mensajes de fallback para timeouts"},
						{"challenge": "Gestión de Tokens JWT", "solution": "Refresh tokens con rotación, blacklist para tokens revocados, expiración configurable por entorno"},
						{"challenge": "Persistencia de Conversaciones", "solution": "Schema optimizado con índices, relación User-Conversation 1:N, soft delete para auditoría"},
						{"challenge": "Validación de Datos", "solution": "DTOs con class-validator, transform pipes globales, validadores personalizados para reglas de negocio"},
						{"challenge": "Desarrollo con Docker", "solution": "Docker Compose con hot-reload, volúmenes para persistencia MySQL, red aislada, variables de entorno seguras"}
					],
					"testing": [
						{"type": "Documentación", "description": "Swagger completo con todos los endpoints documentados", "tools": "@nestjs/swagger"},
						{"type": "Logs", "description": "Sistema de logging estructurado para debug y auditoría", "tools": "Winston"}
					]
				},
				{
					"title": "SNCF IA Reseau Front",
					"subtitle": "Interfaz Web Moderna con Chat Inteligente",
					"description": "Aplicación React single-page con diseño proporcionado por el equipo de House of Coding vía Figma. Interfaz moderna con chat en tiempo real, panel administrativo completo, y sistema de autenticación integrado. Animaciones e interacciones desarrolladas por mí.",
					"features": {
						"frontend": [
							{"name": "Interfaz de Chat", "description": "Interfaz conversacional en tiempo real con historial, indicadores de escritura y renderizado markdown"},
							{"name": "Autenticación", "description": "Login/registro con validación, persistencia de sesión, refresh automático de tokens"},
							{"name": "Panel Administrativo", "description": "Dashboard con estadísticas, gestión de usuarios, visualización de conversaciones y analytics"},
							{"name": "Gestión de Usuarios", "description": "CRUD completo, filtros avanzados, roles y permisos, exportación de datos"},
							{"name": "Historial de Conversaciones", "description": "Visualización detallada de todas las conversaciones con filtros por fecha, usuario y contenido"},
							{"name": "Sistema de Notificaciones", "description": "Toasts con Sonner para feedback de acciones y errores"},
							{"name": "Tablas Interactivas", "description": "TanStack Table con sorting, filtering, pagination y visibilidad de columnas"},
							{"name": "Formularios Validados", "description": "React Hook Form + Zod para validación robusta y type-safe"},
							{"name": "Animaciones Personalizadas", "description": "Transiciones suaves, micro-interacciones y loading states desarrollados por mí"},
							{"name": "Diseño Responsive", "description": "Layout adaptativo para desktop, tablet y móvil basado en Figma de House of Coding"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~12.000",
						"files": "95",
						"components": "48",
						"hooks": "12",
						"pages": "8"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "Hooks reutilizables para auth, llamadas API, gestión de formularios y estado"},
						{"name": "React Query Pattern", "description": "Caché optimizado, invalidación automática, actualizaciones optimistas, manejo de errores"},
						{"name": "Form Management", "description": "React Hook Form + Zod para validación type-safe y rendimiento"},
						{"name": "Route Protection", "description": "Rutas privadas con redirección automática basada en estado de auth"},
						{"name": "Component Composition", "description": "Componentes shadcn/ui personalizables vía props y slots"},
						{"name": "State Management", "description": "React Query para server state, Context API para estado UI global"}
					],
					"decisions": [
						{"decision": "React vs Next.js", "reason": "SPA pura sin necesidad de SSR, autenticación client-side, deploy más simple, routing client-side suficiente"},
						{"decision": "TanStack Query vs Redux", "reason": "Especializado en server state, caché inteligente, menos boilerplate, invalidación automática, devtools excelentes"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste sin dependencias pesadas, personalización total vía Tailwind, accesibilidad Radix, componentes modernos"},
						{"decision": "React Hook Form + Zod", "reason": "Rendimiento superior (menos re-renders), validación type-safe, integración perfecta, bundle menor que Formik"},
						{"decision": "Recharts vs Chart.js", "reason": "Composable, declarativo con React, personalización vía props, TypeScript nativo, responsive out-of-the-box"}
					],
					"challenges": [
						{"challenge": "Implementación del Diseño Figma", "solution": "Fidelidad pixel-perfect al diseño de House of Coding usando Tailwind, sistema de colores y espaciados consistentes, componentes reutilizables"},
						{"challenge": "Animaciones Personalizadas", "solution": "Transiciones CSS personalizadas, framer-motion para animaciones complejas, loading skeletons, micro-interacciones en botones y cards"},
						{"challenge": "Experiencia de Chat en Tiempo Real", "solution": "Polling optimizado con React Query, auto-scroll inteligente, indicadores de escritura, formato markdown"},
						{"challenge": "Gestión de Tokens", "solution": "Interceptor axios para refresh automático, retry de peticiones fallidas, logout en token expirado"},
						{"challenge": "Tablas Performáticas", "solution": "Virtualización con TanStack Table, paginación server-side, lazy loading, memoización de células"}
					]
				}
			]
		}
	}
}
