{
	"backToProjects": "Volver a proyectos",
	"visitProject": "Visitar proyecto",
	"role": "Rol",
	"period": "Período",
	"status": "Estado",
	"client": "Cliente",
	"overview": {
		"title": "Visión General",
		"context": "Contexto",
		"solution": "Solución",
		"myRole": "Mi Rol"
	},
	"stack": {
		"title": "Stack Técnico",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Funcionalidades"
	},
	"challenges": {
		"title": "Desafíos & Soluciones"
	},
	"metrics": {
		"title": "Métricas",
		"linesOfCode": "Líneas de Código",
		"files": "Archivos",
		"modules": "Módulos",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Componentes",
		"hooks": "Hooks",
		"pages": "Páginas"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Decisiones Técnicas",
		"decision": "Decisión",
		"reason": "Justificación"
	},
	"gallery": {
		"title": "Galería"
	},
	"subProjects": "Proyectos",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Ecosistema de IA para el Sector de Construcción",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Abril 2025 - Actual",
			"status": "En Producción",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse es una startup francesa que revoluciona el sector de construcción y renovación energética a través de IA Generativa. El problema: los profesionales de la construcción necesitan verificar el cumplimiento de más de 300 regulaciones técnicas francesas (DTU, normas NF, Eurocodes, etc.), un proceso manual que consume tiempo y es propenso a errores. La solución: un asistente de IA entrenado específicamente en estas regulaciones, respondiendo preguntas técnicas instantáneamente citando las fuentes oficiales.",
				"solution": "El ecosistema consiste en tres componentes internos para que el equipo La Bonne Réponse gestione sus clientes: (1) LBR-API - API REST multi-tenant robusta que gestiona widgets de chat, autenticación doble (usuarios y widgets), integraciones con Stripe/AWS/Brevo, y control de calidad automatizado; (2) IA Factory - Back Office Admin donde el equipo configura chatbots, genera widgets personalizados, gestiona bases de conocimiento y monitorea conversaciones; (3) Portal Usuario - donde los profesionales de la construcción acceden al asistente de IA con historial de conversaciones y gestión de suscripciones. El enlace externo dirige al sitio institucional de la empresa.",
				"myRole": "Actué como Lead Front End y UI/UX Designer, siendo responsable de toda la arquitectura y desarrollo front-end de ambas plataformas (BO y Portal). Creé todo el diseño de interfaz y experiencia de usuario, tomé decisiones técnicas sobre stack y patrones de código. También colaboré activamente en el desarrollo de la API backend junto al equipo House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Herramienta RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robusta creada por el equipo House of Coding usando NestJS, especializada en gestión de widgets de chat con IA. Colaboré implementando las llamadas del dashboard, integración con herramienta RAG y upload de documentos en S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Integración RAG", "description": "Conexión con herramienta de Retrieval-Augmented Generation para respuestas basadas en documentos"},
							{"name": "Multi-Tenancy", "description": "Aislamiento completo de datos por tenant con JWT validado"},
							{"name": "Autenticación Doble", "description": "JWT separado para usuarios (admin, portal) y widgets embebidos"},
							{"name": "CORS Dinámico", "description": "Validación de origen basada en widget integrations en base de datos"},
							{"name": "Gestión de Widgets", "description": "Configuraciones visuales (4 colores), logo, mensajes, Google Analytics"},
							{"name": "Sistema de Referencias", "description": "Upload de documentos, URLs permitidas/bloqueadas, crawling automático"},
							{"name": "Control de Calidad", "description": "Puntos de verificación con preguntas/respuestas, validación automática vía IA"},
							{"name": "Integración Stripe", "description": "Webhooks con validación de firma, gestión de clientes por tenant"},
							{"name": "Upload S3", "description": "URLs prefirmadas para descarga segura con límite de tamaño"},
							{"name": "Rate Limiting", "description": "Throttler personalizado con 100 req/min por IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importación en lote de usuarios con validación y transaction"},
							{"name": "Swagger Automático", "description": "Documentación OpenAPI generada vía decoradores NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "Repositories TypeORM para abstracción de acceso a datos"},
						{"name": "DTO Pattern", "description": "101 DTOs con class-validator para validación de entrada"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard para control de acceso"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext para inyección de contexto"},
						{"name": "Service Layer", "description": "Lógica de negocio aislada de los controllers"},
						{"name": "Module Pattern", "description": "37 módulos NestJS para organización de features"}
					],
					"decisions": [
						{"decision": "Herramienta RAG", "reason": "Sistema para Retrieval-Augmented Generation, elegido por la flexibilidad y control sobre el pipeline de IA"},
						{"decision": "JWT Doble (Usuarios + Widgets)", "reason": "Widgets embebidos en sitios externos necesitan autenticación propia sin exponer credenciales de usuarios"},
						{"decision": "CORS Dinámico vía Base de Datos", "reason": "Cada widget puede embeberse en múltiples dominios, imposible configurar CORS estático"},
						{"decision": "URLs Prefirmadas para S3", "reason": "Descargas seguras sin exponer credenciales AWS, expiración configurable"},
						{"decision": "TypeORM en vez de Prisma", "reason": "Mejor integración con NestJS, soporte de decoradores, rendimiento para queries complejas"}
					],
					"challenges": [
						{"challenge": "CORS Dinámico para Widgets", "solution": "Query en base de datos para validar origen en cada request, caché en memoria para rendimiento"},
						{"challenge": "Webhook Stripe con Raw Body", "solution": "Middleware personalizado para preservar raw body antes del bodyParser de NestJS"},
						{"challenge": "Import en Lote de Usuarios", "solution": "Parsing CSV/Excel con fast-csv, validación en lote, insert con transaction y rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plataforma de Gestión de Chatbots IA",
					"description": "Dashboard administrativo enterprise-grade. Creé el diseño UI/UX, design system y toda la arquitectura de componentes. Desarrollé formularios multi-paso, tablas avanzadas, gestión de widgets, sistema de referencias y todas las demás funcionalidades excepto módulos de usuarios, empresas y QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administrativo", "description": "Interfaz completa para gestión de la plataforma con métricas"},
							{"name": "Formulario Multi-Paso", "description": "Creación de widget en 7 pasos con validación Zod por paso"},
							{"name": "Editor por Secciones", "description": "Accordion con secciones guardables independientemente vía PATCH"},
							{"name": "Widget Configurator", "description": "Preview en tiempo real de las personalizaciones del chatbot"},
							{"name": "DataTable Compuesta", "description": "Tablas con TanStack Table: ordenación, filtros, paginación, selección batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documentos con react-dropzone"},
							{"name": "Sistema de QC", "description": "Control de calidad con import CSV/Excel de puntos de verificación"},
							{"name": "Click Prompts Editor", "description": "Interfaz para crear prompts pre-configurados clicables"},
							{"name": "Gestión Multi-tenant", "description": "Administración de usuarios, empresas y permisos por rol"},
							{"name": "Sistema de Referentials", "description": "Monitoreo de crawler con última ejecución y detección de cambios"},
							{"name": "Cache Invalidation", "description": "Función central que invalida queries relacionadas en cascada"},
							{"name": "Historial de Conversaciones", "description": "Visualización de conversaciones de usuarios con renderizado markdown"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals como composiciones de sub-componentes"},
						{"name": "Custom Hooks", "description": "~40 hooks para lógica reutilizable (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextos para estado global de formularios multi-paso"},
						{"name": "Optimistic Updates", "description": "React Query con mutaciones optimistas para UX reactiva"},
						{"name": "Adapter Pattern", "description": "Transformación de datos API hacia formato UI"},
						{"name": "Feature-based Structure", "description": "Organización por features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context para estado UI (formularios), React Query para estado servidor"},
						{"decision": "Accordion para edición", "reason": "Permite guardar secciones independientemente sin bloquear al usuario"}
					],
					"challenges": [
						{"challenge": "Formulario de 7 Pasos", "solution": "Context para estado global, validación Zod por paso, hasStepErrors() para feedback visual"},
						{"challenge": "Upload con Preview", "solution": "FileReader para preview local inmediato, estado separado para preview vs saved"},
						{"challenge": "Edición por Secciones", "solution": "Accordion con botón Save por sección, PATCH para updates parciales, track changes"},
						{"challenge": "Cache Invalidation en Cascada", "solution": "Función refetchAllWidgetData() invalidando queries relacionadas en orden correcto"}
					]
				},
				{
					"title": "Portal Usuario",
					"subtitle": "Portal Web con Widget de Chat Integrado",
					"description": "Aplicación completa construida desde cero. Implementé autenticación robusta, refresh automático de tokens, integración Stripe, widget de chat en iframe aislado y refactorización completa de la versión Webflow.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10 minutos antes de expiración, reprogramación continua"},
							{"name": "Widget en Iframe", "description": "Aislamiento completo CSS/JS con sandbox, comunicación vía postMessage"},
							{"name": "Integración Stripe", "description": "Pricing table embebida, verificación de estado, billing portal"},
							{"name": "Sistema de Autenticación", "description": "Login, registro, activación de cuenta, reset de contraseña con tokens"},
							{"name": "Soporte B2B y B2C", "description": "Lógica de suscripción diferenciada por tipo de tenant"},
							{"name": "Gestión de Conversaciones", "description": "Sidebar con lista de conversaciones, crear nueva, continuar existente"},
							{"name": "Páginas de Presentación", "description": "URLs dinámicas por nombre para demos sin autenticación"},
							{"name": "Gestión de Cuenta", "description": "Editar perfil, título profesional, sector, cambiar contraseña con validación robusta"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Decodificación JWT + setTimeout para refresh proactivo"},
						{"name": "Iframe Isolation", "description": "Widget en sandbox con comunicación vía postMessage"},
						{"name": "Route Guards", "description": "Protección de rutas con verificación de autenticación y suscripción"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations para lógica encapsulada"}
					],
					"decisions": [
						{"decision": "Iframe para Widget", "reason": "Aislamiento completo CSS/JS, evita conflictos de estilo con el portal"},
						{"decision": "Refresh Proactivo", "reason": "Refresh 10min antes evita expiración durante uso activo"},
						{"decision": "Stripe Pricing Table", "reason": "Componente embebido elimina necesidad de UI personalizada para planes"},
						{"decision": "B2B sin pago", "reason": "Empresas B2B tienen contrato directo, no necesitan checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automático", "solution": "Decodificar JWT para obtener expiración, setTimeout 10min antes, reprogramar tras éxito"},
						{"challenge": "Widget en Iframe Aislado", "solution": "Sandbox con allow-scripts allow-same-origin, parámetros vía query string, postMessage"},
						{"challenge": "Estado de Suscripción", "solution": "Hook useSubscription() con lógica centralizada para B2B (sin pago) y B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Ecosistema Multi-Plataforma", "solution": "Arquitectura modular con API compartida entre BO y Portal, permitiendo evolución independiente de cada aplicación"},
				{"challenge": "Autenticación para Contextos Diferentes", "solution": "Sistema JWT doble: uno para usuarios autenticados (admin/portal) y otro para widgets embebidos en sitios externos"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plataformas de Formación Profesional",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Marzo 2025 - Actual",
			"status": "En Producción",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs es un organismo de formación profesional francés que acompaña a los aprendices en su trayectoria de desarrollo. Cada aprendiz es acompañado por un tutor que valida sus misiones y etapas de aprendizaje. El problema: seguimiento pedagógico fragmentado en hojas de cálculo y emails, sin trazabilidad centralizada del progreso, evaluaciones manuales dispersas (PIX, Cléa, soft skills), y comunicación tutor-aprendiz sin historial organizado.",
				"solution": "El ecosistema consiste en dos plataformas complementarias: (1) LINK-Parcours - Dashboard administrativo enterprise-grade para gestión de sesiones de formación, usuarios con 8 niveles de roles, evaluaciones de posicionamiento (PIX, Cléa, soft skills), y seguimiento de progreso (béabas, missions); (2) Tuto-Mission - PWA mobile-first para acompañamiento pedagógico en tiempo real, donde los tutores monitorean aprendices a través de chat con soporte de media y validación de etapas.",
				"myRole": "En LINK-Parcours, actué como Lead Front End y UI/UX Designer, creando todo el diseño de la interfaz administrativa e implementando el sistema completo. En Tuto-Mission, implementé el diseño recibido via Figma de House of Coding, desarrollando estrategias de cache avanzadas para compensar API legacy y crear una experiencia fluida."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (equipo House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administrativo de Formación",
					"description": "Plataforma administrativa completa para gestión de sesiones de formación, usuarios y evaluaciones. Creé todo el diseño UI/UX e implementé el sistema con control de acceso basado en 8 niveles de roles, tablas paginadas server-side, y formularios complejos con validación i18n.",
					"features": {
						"frontend": [
							{"name": "Gestión de Usuarios", "description": "CRUD completo con 8 niveles de roles (superAdmin hasta aprendiz)"},
							{"name": "Gestión de Sesiones", "description": "Creación de sesiones con múltiples días (session_jours) y participantes"},
							{"name": "Evaluación de Posicionamiento", "description": "Scores PIX, resultados Cléa, soft skills games, entrevistas"},
							{"name": "Seguimiento de Progreso", "description": "Béabas y missions con cálculo de porcentaje global"},
							{"name": "Tablas Avanzadas", "description": "TanStack Table con ordenación, filtros, paginación server-side"},
							{"name": "URL State Management", "description": "Filtros persistidos en URL via nuqs para compartir"},
							{"name": "Formularios Validados", "description": "React Hook Form + Zod con mensajes i18n en francés"},
							{"name": "Upload de Foto", "description": "Drag & drop con preview y gestión de perfil"},
							{"name": "Dashboard con Gráficos", "description": "Visualizaciones con Recharts para métricas"},
							{"name": "Sistema de Roles", "description": "RoleProtectedRoute + useRoleBasedRedirect para control de acceso"},
							{"name": "Pre-inscripciones", "description": "Gestión de candidatos por sesión de formación"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 niveles jerárquicos con RoleProtectedRoute y redirección automática"},
						{"name": "Container/Presenter", "description": "Hooks de datos separados de componentes de tabla"},
						{"name": "URL State Management", "description": "nuqs sincroniza filtros/paginación con query parameters"},
						{"name": "Schema Validation", "description": "Zod dinámico con traducciones i18n para mensajes de error"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI con class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adaptan estructura API al formato UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Productividad aumentada, design system integrado, purge automático"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives accesibles sin styling impuesto, control total sobre apariencia"},
						{"decision": "nuqs para URL state", "reason": "Sincronización bidireccional automática, type-safe con parsers"},
						{"decision": "Paginación Híbrida", "reason": "Server-side para users/sessions (gran volumen), client-side para aprendices (filtrado rápido)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (menos re-renders), integración nativa, mejor TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Niveles de Roles", "solution": "Enum UserGroupCode con códigos numéricos jerárquicos, matriz de permisos por ruta"},
						{"challenge": "Filtros Persistentes", "solution": "Estado en URL via nuqs + location.state para contexto de navegación"},
						{"challenge": "Sistema de Posicionamiento", "solution": "Componentes dedicados por tipo (PIX, Cléa, soft skills) + hook usePositioning centralizado"},
						{"challenge": "Formularios Multi-Etapas", "solution": "Tabs organizando secciones, schema Zod parcial por sección, validación en submit"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA de Acompañamiento Pedagógico",
					"description": "Aplicación mobile-first para acompañamiento pedagógico en tiempo real. Implementé el diseño recibido via Figma, desarrollando sistema de chat con soporte de media, validación de etapas, y estrategia de cache sofisticada para compensar API legacy.",
					"features": {
						"frontend": [
							{"name": "Sistema de Chat", "description": "Mensajes en tiempo real tutor ↔ aprendiz con historial persistente"},
							{"name": "Upload de Media", "description": "Fotos y videos pedagógicos con preview antes del envío"},
							{"name": "Validación de Etapas", "description": "Tutor valida o solicita rehacerlo con feedback visual inmediato"},
							{"name": "Videos con Timestamps", "description": "Player React Player con timestamps específicos por etapa"},
							{"name": "Auto-scroll Inteligente", "description": "Hook useScrollToBottom observa cambios y ejecuta scroll"},
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10min antes de expiración, transparente al usuario"},
							{"name": "Múltiples Aprendices", "description": "Selección automática si tutor tiene 1, página de selección si N"},
							{"name": "Mensajes de Pedagogía", "description": "Mensajes automáticos del sistema con estilización diferenciada"},
							{"name": "Optimistic Updates", "description": "Mensajes aparecen instantáneamente antes de confirmación del servidor"},
							{"name": "Cache Performático", "description": "Stale-while-revalidate para navegación zero-latency"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centraliza lógica de autenticación con variables globales"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulan lógica de datos"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo por tipo de mensaje"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observa dependencias para auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrappea requests con JWT y retry de token"},
						{"name": "Optimistic Updates", "description": "React Query con mutaciones optimistas y rollback automático"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automático, mutations con optimistic updates, menos boilerplate"},
						{"decision": "CSS Puro", "reason": "Proyecto mobile-first pequeño, performance sin runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT en cookie para seguridad, datos de usuario en localStorage para acceso rápido"},
						{"decision": "Upload Directo via API", "reason": "Arquitectura más simple, backend controla validaciones"}
					],
					"challenges": [
						{"challenge": "API Legacy Lenta", "solution": "Cache sofisticado: staleTime 5-10min, gcTime 30min, placeholderData para UX instantánea"},
						{"challenge": "Refresh de Token Transparente", "solution": "Timer 10min antes de expiración + handleTokenExpiration global para errores 401"},
						{"challenge": "Upload con Preview", "solution": "URL.createObjectURL() para preview local, envío separado de texto y media"},
						{"challenge": "Scroll Automático en Chat", "solution": "Hook customizado observa [messages, isLoading] y ejecuta scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Dos Plataformas Complementarias", "solution": "Arquitectura consistente con React Query en ambas, patterns reutilizables"},
				{"challenge": "API PHP Legacy Compartida", "solution": "Estrategias de cache en frontend para crear experiencia premium sin modificar backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Capa de Abstracción para Dispositivos IoT",
			"role": "Backend Developer",
			"period": "Noviembre 2024 - Actual",
			"status": "En Desarrollo",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell es una empresa de climatización que ofrece dispositivos IoT (aire acondicionado, termostatos, sensores) controlados vía aplicación móvil. Para conectar dispositivos de múltiples fabricantes, la empresa utilizaba un servicio tercerizado como intermediario. El problema: costos recurrentes de licencia por dispositivo, vendor lock-in, latencia adicional, e imposibilidad de customizar sin depender del proveedor.",
				"solution": "Desarrollé un IoT Router propio - una capa de abstracción que conecta directamente a las APIs de los fabricantes de dispositivos, normaliza los diferentes formatos en una API unificada, mantiene compatibilidad con el formato esperado por el mobile legacy, y escala para soportar nuevos fabricantes vía sistema de plugins. La solución eliminó costos mensuales y dio independencia tecnológica total a la empresa.",
				"myRole": "Asumí un proyecto iniciado por un colega de Amiltone y realicé una refactorización masiva, definiendo buenas prácticas y adaptando la arquitectura para escalar. Diseñé la arquitectura de plugins para múltiples fabricantes, desarrollé sistema de rate limiting distribuido con Redis, e integré AWS Lambda para comandos programados. También hice intervenciones en la API server estándar de Airwell para integrar el IoT Router, y realicé debugging completo de la app mobile React Native que no funcionaba - identificando problemas y enviando informes al equipo."
			},
			"stack": {
				"frontend": ["React Native (debugging + informes para equipo Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Sistema de Plugins Multi-Fabricante + Comandos Programados",
					"description": "Capa de abstracción con arquitectura de plugins para integración con múltiples fabricantes IoT. Cada fabricante es un módulo aislado que implementa una interfaz común. Incluye sistema de comandos programados vía AWS Lambda + Bull Queue con retry automático.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Sistema extensible donde cada fabricante es un plugin aislado implementando IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Descubrimiento automático de dispositivos por usuario y fabricante con extracción de metadatos"},
							{"name": "Data Handler", "description": "Lectura de status, mediciones (temperatura, humedad, CO2) con normalización de unidades"},
							{"name": "Command Handler", "description": "Ejecución de comandos (encender/apagar, ajustar temperatura) con retry automático"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue para comandos programados con retry exponencial"},
							{"name": "OAuth 2.0 Flow", "description": "Flujo de autenticación completo con refresh automático de tokens cifrados"},
							{"name": "Rate Limiting", "description": "Algoritmo sliding window en Redis con reglas customizadas por fabricante"},
							{"name": "Adapter Pattern", "description": "Transformación de datos del formato fabricante hacia formato normalizado compatible con mobile"},
							{"name": "Configuration as Code", "description": "Configuración de socios y dispositivos vía YAML validado por JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulando acceso a datos con queries optimizadas"},
							{"name": "Interceptors & Guards", "description": "Logging estructurado y manejo de errores consistente en toda la aplicación"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricantes como módulos aislados implementando interfaz común (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separación de responsabilidades: handlers Discovery, Data y Command especializados"},
						{"name": "Strategy Pattern", "description": "Cada plugin implementa su propia estrategia de autenticación (OAuth, API Key, propietaria)"},
						{"name": "Adapter Pattern", "description": "Normalización de datos heterogéneos hacia formato único compatible con mobile legacy"},
						{"name": "Queue Pattern", "description": "Bull Queue para comandos programados con desacoplamiento trigger/ejecución"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulando acceso a datos con queries centralizadas"},
						{"name": "Factory Pattern", "description": "Rate limit calculators específicos por fabricante con reglas customizadas"},
						{"name": "Decorator Pattern", "description": "Interceptors y filters decorando operaciones con logging y error handling"}
					],
					"decisions": [
						{"decision": "Redis para Rate Limiting", "reason": "Distribuido, persistente, sliding window preciso, reutilizado para colas Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Ya tenemos Redis, UI de monitoreo (Bull Board), menos latencia que SQS"},
						{"decision": "AES-256-GCM en Base", "reason": "Simplicidad operacional vs Vault dedicado, suficiente para el caso de uso"}
					],
					"challenges": [
						{"challenge": "APIs Heterogéneas", "solution": "Plugin pattern aísla complejidad - cada plugin habla el 'idioma' del fabricante"},
						{"challenge": "Rate Limiting Complejo", "solution": "Configuración por fabricante + sliding window Redis + métricas para ajuste fino"},
						{"challenge": "Compatibilidad Mobile Legacy", "solution": "Adapter pattern normaliza respuestas al formato esperado por la app antigua"},
						{"challenge": "Comandos Programados", "solution": "AWS EventBridge → Lambda → Bull Queue con retry exponencial y auditoría"}
					]
				}
			],
			"challenges": [
				{"challenge": "Código Mobile Legacy Problemático (Mayor Desafío)", "solution": "Nada funcionaba - código sucio, sin patrones, errores en cascada. Realicé debugging completo identificando 73 errores críticos, refactoricé el backend para normalizar datos y minimizar intervenciones en el frontend legacy caótico"},
				{"challenge": "Reemplazar Servicio Tercerizado", "solution": "Arquitectura de plugins permitió integración directa con fabricantes manteniendo compatibilidad mobile"}
			]
		}
	}
}
