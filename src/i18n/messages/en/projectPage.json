{
	"backToProjects": "Back to projects",
	"visitProject": "Visit project",
	"role": "Role",
	"period": "Period",
	"status": "Status",
	"client": "Client",
	"overview": {
		"title": "Overview",
		"context": "Context",
		"solution": "Solution",
		"myRole": "My Role"
	},
	"stack": {
		"title": "Tech Stack",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Features"
	},
	"challenges": {
		"title": "Challenges & Solutions"
	},
	"metrics": {
		"title": "Metrics",
		"linesOfCode": "Lines of Code",
		"files": "Files",
		"modules": "Modules",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Components",
		"hooks": "Hooks",
		"pages": "Pages"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Technical Decisions",
		"decision": "Decision",
		"reason": "Rationale"
	},
	"gallery": {
		"title": "Gallery"
	},
	"subProjects": "Projects",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "AI Ecosystem for the Construction Sector",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "April 2025 - Present",
			"status": "In Production",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse is a French startup revolutionizing the construction and energy renovation sector through Generative AI. The problem: construction professionals need to verify compliance with over 300 French technical regulations (DTU, NF standards, Eurocodes, etc.), a manual process that is time-consuming and error-prone. The solution: an AI assistant specifically trained on these regulations, answering technical questions instantly while citing official sources.",
				"solution": "The ecosystem consists of three internal components for the La Bonne Réponse team to manage their clients: (1) LBR-API - a robust multi-tenant REST API managing chat widgets, dual authentication (users and widgets), integrations with Stripe/AWS/Brevo, and automated quality control; (2) IA Factory - Back Office Admin where the team configures chatbots, generates custom widgets, manages knowledge bases and monitors conversations; (3) User Portal - where construction professionals access the AI assistant with conversation history and subscription management. The external link directs to the company's institutional website.",
				"myRole": "I served as Lead Front End and UI/UX Designer, responsible for the entire front-end architecture and development of both platforms (BO and Portal). I created all interface design and user experience, made technical decisions about stack and code patterns. I also actively collaborated on backend API development with the House of Coding team."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "RAG Tool", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "Multi-Tenant REST API",
					"description": "Robust REST API created by the House of Coding team using NestJS, specialized in AI chat widget management. I collaborated by implementing dashboard API calls, RAG tool integration and S3 document upload.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "RAG Integration", "description": "Connection with Retrieval-Augmented Generation tool for document-based responses"},
							{"name": "Multi-Tenancy", "description": "Complete data isolation per tenant with validated JWT"},
							{"name": "Dual Authentication", "description": "Separate JWT for users (admin, portal) and embedded widgets"},
							{"name": "Dynamic CORS", "description": "Origin validation based on widget integrations in database"},
							{"name": "Widget Management", "description": "Visual configurations (4 colors), logo, messages, Google Analytics"},
							{"name": "Reference System", "description": "Document upload, allowed/blocked URLs, automatic crawling"},
							{"name": "Quality Control", "description": "Verification points with Q&A, automatic validation via AI"},
							{"name": "Stripe Integration", "description": "Webhooks with signature validation, client management per tenant"},
							{"name": "S3 Upload", "description": "Presigned URLs for secure download with size limit"},
							{"name": "Rate Limiting", "description": "Custom throttler with 100 req/min per IP + user_id"},
							{"name": "CSV/Excel Import", "description": "Batch user import with validation and transaction"},
							{"name": "Auto Swagger", "description": "OpenAPI documentation generated via NestJS decorators"}
						]
					},
					"metrics": {
						"linesOfCode": "~15,000-20,000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "TypeORM repositories for data access abstraction"},
						{"name": "DTO Pattern", "description": "101 DTOs with class-validator for input validation"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard for access control"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext for context injection"},
						{"name": "Service Layer", "description": "Business logic isolated from controllers"},
						{"name": "Module Pattern", "description": "37 NestJS modules for feature organization"}
					],
					"decisions": [
						{"decision": "RAG Tool", "reason": "System for Retrieval-Augmented Generation, chosen for flexibility and control over the AI pipeline"},
						{"decision": "Dual JWT (Users + Widgets)", "reason": "Widgets embedded on external sites need their own authentication without exposing user credentials"},
						{"decision": "Dynamic CORS via Database", "reason": "Each widget can be embedded on multiple domains, impossible to configure static CORS"},
						{"decision": "Presigned URLs for S3", "reason": "Secure downloads without exposing AWS credentials, configurable expiration"},
						{"decision": "TypeORM over Prisma", "reason": "Better NestJS integration, decorator support, performance for complex queries"}
					],
					"challenges": [
						{"challenge": "Dynamic CORS for Widgets", "solution": "Database query to validate origin on each request, in-memory cache for performance"},
						{"challenge": "Stripe Webhook with Raw Body", "solution": "Custom middleware to preserve raw body before NestJS bodyParser"},
						{"challenge": "Batch User Import", "solution": "CSV/Excel parsing with fast-csv, batch validation, insert with transaction and rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "AI Chatbot Management Platform",
					"description": "Enterprise-grade admin dashboard. I created the UI/UX design, design system and entire component architecture. I developed multi-step forms, advanced tables, widget management, reference system and all other features except user, company and QA modules.",
					"features": {
						"frontend": [
							{"name": "Admin Dashboard", "description": "Complete platform management interface with metrics"},
							{"name": "Multi-Step Form", "description": "Widget creation in 7 steps with Zod validation per step"},
							{"name": "Section Editor", "description": "Accordion with independently saveable sections via PATCH"},
							{"name": "Widget Configurator", "description": "Real-time preview of chatbot customizations"},
							{"name": "Composed DataTable", "description": "Tables with TanStack Table: sorting, filters, pagination, batch selection"},
							{"name": "Knowledge Base UI", "description": "Drag-and-drop document upload with react-dropzone"},
							{"name": "QC System", "description": "Quality control with CSV/Excel import of verification points"},
							{"name": "Click Prompts Editor", "description": "Interface for creating clickable pre-configured prompts"},
							{"name": "Multi-tenant Management", "description": "User, company and role-based permission administration"},
							{"name": "Referentials System", "description": "Crawler monitoring with last execution and change detection"},
							{"name": "Cache Invalidation", "description": "Central function invalidating related queries in cascade"},
							{"name": "Conversation History", "description": "User conversation viewing with markdown rendering"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32,000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals as compositions of sub-components"},
						{"name": "Custom Hooks", "description": "~40 hooks for reusable logic (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contexts for global state of multi-step forms"},
						{"name": "Optimistic Updates", "description": "React Query with optimistic mutations for reactive UX"},
						{"name": "Adapter Pattern", "description": "API data transformation to UI format"},
						{"name": "Feature-based Structure", "description": "Organization by features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context for UI state (forms), React Query for server state"},
						{"decision": "Accordion for editing", "reason": "Allows saving sections independently without blocking the user"}
					],
					"challenges": [
						{"challenge": "7-Step Form", "solution": "Context for global state, Zod validation per step, hasStepErrors() for visual feedback"},
						{"challenge": "Upload with Preview", "solution": "FileReader for immediate local preview, separate state for preview vs saved"},
						{"challenge": "Section Editing", "solution": "Accordion with Save button per section, PATCH for partial updates, track changes"},
						{"challenge": "Cascade Cache Invalidation", "solution": "refetchAllWidgetData() function invalidating related queries in correct order"}
					]
				},
				{
					"title": "User Portal",
					"subtitle": "Web Portal with Integrated Chat Widget",
					"description": "Complete application built from scratch. I implemented robust authentication, automatic token refresh, Stripe integration, chat widget in isolated iframe and complete refactoring from Webflow version.",
					"features": {
						"frontend": [
							{"name": "Automatic Token Refresh", "description": "JWT refresh 10 minutes before expiration, continuous rescheduling"},
							{"name": "Iframe Widget", "description": "Complete CSS/JS isolation with sandbox, postMessage communication"},
							{"name": "Stripe Integration", "description": "Embedded pricing table, status verification, billing portal"},
							{"name": "Authentication System", "description": "Login, registration, account activation, password reset with tokens"},
							{"name": "B2B and B2C Support", "description": "Differentiated subscription logic by tenant type"},
							{"name": "Conversation Management", "description": "Sidebar with conversation list, create new, continue existing"},
							{"name": "Presentation Pages", "description": "Dynamic URLs by name for demos without authentication"},
							{"name": "Account Management", "description": "Edit profile, professional title, sector, change password with robust validation"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6,300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "JWT decoding + setTimeout for proactive refresh"},
						{"name": "Iframe Isolation", "description": "Widget in sandbox with postMessage communication"},
						{"name": "Route Guards", "description": "Route protection with authentication and subscription verification"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations for encapsulated logic"}
					],
					"decisions": [
						{"decision": "Iframe for Widget", "reason": "Complete CSS/JS isolation, avoids style conflicts with the portal"},
						{"decision": "Proactive Refresh", "reason": "Refresh 10min before avoids expiration during active use"},
						{"decision": "Stripe Pricing Table", "reason": "Embedded component eliminates need for custom UI for plans"},
						{"decision": "B2B without payment", "reason": "B2B companies have direct contract, no need for checkout"}
					],
					"challenges": [
						{"challenge": "Automatic Token Refresh", "solution": "Decode JWT to get expiration, setTimeout 10min before, reschedule after success"},
						{"challenge": "Isolated Iframe Widget", "solution": "Sandbox with allow-scripts allow-same-origin, parameters via query string, postMessage"},
						{"challenge": "Subscription Status", "solution": "useSubscription() hook with centralized logic for B2B (no payment) and B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Multi-Platform Ecosystem", "solution": "Modular architecture with shared API between BO and Portal, allowing independent evolution of each application"},
				{"challenge": "Authentication for Different Contexts", "solution": "Dual JWT system: one for authenticated users (admin/portal) and one for widgets embedded on external sites"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Professional Training Platforms",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "March 2025 - Present",
			"status": "In Production",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs is a French professional training organization that supports apprentices (apprenants) in their development journey. Each apprenant is accompanied by a tuteur who validates their missions and learning stages. The problem: fragmented pedagogical tracking in spreadsheets and emails, no centralized progress traceability, scattered manual assessments (PIX, Cléa, soft skills), and tutor-apprenant communication without organized history.",
				"solution": "The ecosystem consists of two complementary platforms: (1) LINK-Parcours - Enterprise-grade admin dashboard for training session management, users with 8 role levels, positioning assessments (PIX, Cléa, soft skills), and progress tracking (béabas, missions); (2) Tuto-Mission - Mobile-first PWA for real-time pedagogical monitoring, where tutors track apprenants through media-supported chat and stage validation.",
				"myRole": "In LINK-Parcours, I served as Lead Front End and UI/UX Designer, creating the entire admin interface design and implementing the complete system. In Tuto-Mission, I implemented the design received via Figma from House of Coding, developing advanced caching strategies to compensate for legacy API and create a fluid experience."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["PHP REST API (House of Coding team)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Training Admin Dashboard",
					"description": "Complete admin platform for training session management, users, and assessments. I created the entire UI/UX design and implemented the system with access control based on 8 role levels, server-side paginated tables, and complex forms with i18n validation.",
					"features": {
						"frontend": [
							{"name": "User Management", "description": "Full CRUD with 8 role levels (superAdmin to apprenant)"},
							{"name": "Session Management", "description": "Session creation with multiple days (session_jours) and participants"},
							{"name": "Positioning Assessment", "description": "PIX scores, Cléa results, soft skills games, interviews"},
							{"name": "Progress Tracking", "description": "Béabas and missions with global percentage calculation"},
							{"name": "Advanced Tables", "description": "TanStack Table with sorting, filters, server-side pagination"},
							{"name": "URL State Management", "description": "Filters persisted in URL via nuqs for sharing"},
							{"name": "Validated Forms", "description": "React Hook Form + Zod with i18n messages in French"},
							{"name": "Photo Upload", "description": "Drag & drop with preview and profile management"},
							{"name": "Dashboard with Charts", "description": "Visualizations with Recharts for metrics"},
							{"name": "Role System", "description": "RoleProtectedRoute + useRoleBasedRedirect for access control"},
							{"name": "Pre-registrations", "description": "Candidate management by training session"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21,500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 hierarchical levels with RoleProtectedRoute and automatic redirection"},
						{"name": "Container/Presenter", "description": "Data hooks separated from table components"},
						{"name": "URL State Management", "description": "nuqs syncs filters/pagination with query parameters"},
						{"name": "Schema Validation", "description": "Dynamic Zod with i18n translations for error messages"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI with class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adapt API structure to UI format"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Increased productivity, integrated design system, automatic purge"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Accessible primitives without imposed styling, full control over appearance"},
						{"decision": "nuqs for URL state", "reason": "Automatic bidirectional sync, type-safe with parsers"},
						{"decision": "Hybrid Pagination", "reason": "Server-side for users/sessions (large volume), client-side for apprenants (fast filtering)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (fewer re-renders), native integration, better TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Role Levels", "solution": "UserGroupCode enum with hierarchical numeric codes, permission matrix per route"},
						{"challenge": "Persistent Filters", "solution": "URL state via nuqs + location.state for navigation context"},
						{"challenge": "Positioning System", "solution": "Dedicated components per type (PIX, Cléa, soft skills) + centralized usePositioning hook"},
						{"challenge": "Multi-Step Forms", "solution": "Tabs organizing sections, partial Zod schema per section, validation on submit"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "Pedagogical Monitoring PWA",
					"description": "Mobile-first application for real-time pedagogical monitoring. I implemented the design received via Figma, developing a chat system with media support, stage validation, and sophisticated caching strategy to compensate for legacy API.",
					"features": {
						"frontend": [
							{"name": "Chat System", "description": "Real-time messages tutor ↔ apprenant with persistent history"},
							{"name": "Media Upload", "description": "Photos and pedagogical videos with preview before sending"},
							{"name": "Stage Validation", "description": "Tuteur validates or requests redo with immediate visual feedback"},
							{"name": "Videos with Timestamps", "description": "React Player with stage-specific timestamps"},
							{"name": "Smart Auto-scroll", "description": "useScrollToBottom hook observes changes and executes scroll"},
							{"name": "Automatic Token Refresh", "description": "JWT refresh 10min before expiration, transparent to user"},
							{"name": "Multiple Apprenants", "description": "Auto-selection if tuteur has 1, selection page if N"},
							{"name": "Pedagogy Messages", "description": "Automatic system messages with differentiated styling"},
							{"name": "Optimistic Updates", "description": "Messages appear instantly before server confirmation"},
							{"name": "Performant Cache", "description": "Stale-while-revalidate for zero-latency navigation"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4,200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centralizes auth logic with global variables"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulate data logic"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo per message type"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observes dependencies for auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wraps requests with JWT and token retry"},
						{"name": "Optimistic Updates", "description": "React Query with optimistic mutations and automatic rollback"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Automatic cache, mutations with optimistic updates, less boilerplate"},
						{"decision": "Pure CSS", "reason": "Small mobile-first project, performance without CSS-in-JS runtime"},
						{"decision": "localStorage + Cookies", "reason": "JWT in cookie for security, user data in localStorage for quick access"},
						{"decision": "Direct Upload via API", "reason": "Simpler architecture, backend controls validations"}
					],
					"challenges": [
						{"challenge": "Slow Legacy API", "solution": "Sophisticated cache: staleTime 5-10min, gcTime 30min, placeholderData for instant UX"},
						{"challenge": "Transparent Token Refresh", "solution": "Timer 10min before expiration + global handleTokenExpiration for 401 errors"},
						{"challenge": "Upload with Preview", "solution": "URL.createObjectURL() for local preview, separate text and media sending"},
						{"challenge": "Auto-scroll in Chat", "solution": "Custom hook observes [messages, isLoading] and executes scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Two Complementary Platforms", "solution": "Consistent architecture with React Query in both, reusable patterns"},
				{"challenge": "Shared Legacy PHP API", "solution": "Frontend caching strategies to create premium experience without backend modifications"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Abstraction Layer for IoT Devices",
			"role": "Backend Developer",
			"period": "November 2024 - Present",
			"status": "In Development",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell is a climate control company offering IoT devices (air conditioning, thermostats, sensors) controlled via mobile app. To connect devices from multiple manufacturers, the company used a third-party service acting as an intermediary. The problem: recurring licensing costs per device, vendor lock-in, additional latency, and inability to customize without depending on the supplier.",
				"solution": "Currently the company uses a third-party external API to connect devices, generating high monthly costs. The IoT Router is an abstraction layer that connects directly to manufacturer device APIs, normalizes different formats into a unified API, maintains compatibility with the legacy mobile app's expected format, and scales to support new manufacturers via a plugin system. The solution will eliminate these costs and give the company complete technological independence.",
				"myRole": "I took over a project started by an Amiltone colleague and performed a massive refactoring, defining best practices and adapting the architecture to scale. I designed the plugin architecture for multiple manufacturers, developed a distributed rate limiting system with Redis, and integrated AWS Lambda for scheduled commands. I also made interventions in Airwell's standard API server to integrate the IoT Router, and performed complete debugging of the React Native mobile app which wasn't working - identifying issues and sending reports to the team."
			},
			"stack": {
				"frontend": ["React Native (debugging + reports for Airwell team)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Multi-Manufacturer Plugin System + Scheduled Commands",
					"description": "Abstraction layer with plugin architecture for integration with multiple IoT manufacturers. Each manufacturer is an isolated module implementing a common interface. Includes scheduled command system via AWS Lambda + Bull Queue with automatic retry.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Extensible system where each manufacturer is an isolated plugin implementing IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Automatic device discovery per user per manufacturer with metadata extraction"},
							{"name": "Data Handler", "description": "Status reading, measurements (temperature, humidity, CO2) with unit normalization"},
							{"name": "Command Handler", "description": "Command execution (on/off, temperature adjustment) with automatic retry"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue for scheduled commands with exponential retry"},
							{"name": "OAuth 2.0 Flow", "description": "Complete authentication flow with automatic refresh of encrypted tokens"},
							{"name": "Rate Limiting", "description": "Sliding window algorithm in Redis with custom rules per manufacturer"},
							{"name": "Adapter Pattern", "description": "Data transformation from manufacturer format to normalized mobile-compatible format"},
							{"name": "Configuration as Code", "description": "Partner and device configuration via YAML validated by JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulating data access with optimized queries"},
							{"name": "Interceptors & Guards", "description": "Structured logging and consistent error handling throughout the application"}
						]
					},
					"metrics": {
						"linesOfCode": "~15,000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Manufacturers as isolated modules implementing common interface (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separation of responsibilities: specialized Discovery, Data, and Command handlers"},
						{"name": "Strategy Pattern", "description": "Each plugin implements its own authentication strategy (OAuth, API Key, proprietary)"},
						{"name": "Adapter Pattern", "description": "Normalization of heterogeneous data to single format compatible with legacy mobile"},
						{"name": "Queue Pattern", "description": "Bull Queue for scheduled commands with trigger/execution decoupling"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulating data access with centralized queries"},
						{"name": "Factory Pattern", "description": "Manufacturer-specific rate limit calculators with custom rules"},
						{"name": "Decorator Pattern", "description": "Interceptors and filters decorating operations with logging and error handling"}
					],
					"decisions": [
						{"decision": "Redis for Rate Limiting", "reason": "Distributed, persistent, precise sliding window, reused for Bull queues"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Already have Redis, monitoring UI (Bull Board), less latency than SQS"},
						{"decision": "AES-256-GCM in Database", "reason": "Operational simplicity vs dedicated Vault, sufficient for the use case"}
					],
					"challenges": [
						{"challenge": "Heterogeneous APIs", "solution": "Plugin pattern isolates complexity - each plugin speaks the manufacturer's 'language'"},
						{"challenge": "Complex Rate Limiting", "solution": "Per-manufacturer configuration + Redis sliding window + metrics for fine-tuning"},
						{"challenge": "Legacy Mobile Compatibility", "solution": "Adapter pattern normalizes responses to format expected by legacy app"},
						{"challenge": "Scheduled Commands", "solution": "AWS EventBridge → Lambda → Bull Queue with exponential retry and auditing"}
					]
				}
			],
			"challenges": [
				{"challenge": "Problematic Legacy Mobile Code (Biggest Challenge)", "solution": "Nothing was working - dirty code, no patterns, cascading errors. I performed complete debugging identifying 73 critical errors, refactored the backend to normalize data and minimize interventions in the chaotic legacy frontend"},
				{"challenge": "Replace Third-Party Service", "solution": "Plugin architecture enabled direct manufacturer integration while maintaining mobile compatibility"}
			]
		}
	}
}
