{
	"backToProjects": "Back to projects",
	"visitProject": "Visit project",
	"role": "Role",
	"period": "Period",
	"status": "Status",
	"client": "Client",
	"overview": {
		"title": "Overview",
		"context": "Context",
		"solution": "Solution",
		"myRole": "My Role"
	},
	"stack": {
		"title": "Tech Stack",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Features"
	},
	"challenges": {
		"title": "Challenges & Solutions"
	},
	"metrics": {
		"title": "Metrics",
		"linesOfCode": "Lines of Code",
		"files": "Files",
		"modules": "Modules",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Components",
		"hooks": "Hooks",
		"pages": "Pages"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Technical Decisions",
		"decision": "Decision",
		"reason": "Rationale"
	},
	"testing": {
		"title": "Testing Strategy",
		"type": "Type",
		"tools": "Tools",
		"coverage": "Coverage"
	},
	"gallery": {
		"title": "Gallery"
	},
	"subProjects": "Projects",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "AI Ecosystem for the Construction Sector",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "April 2025 - Present",
			"status": "In Production",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse is a French startup revolutionizing the construction and energy renovation sector through Generative AI. The problem: construction professionals need to verify compliance with over 300 French technical regulations (DTU, NF standards, Eurocodes, etc.), a manual process that is time-consuming and error-prone. The solution: an AI assistant specifically trained on these regulations, answering technical questions instantly while citing official sources.",
				"solution": "The ecosystem consists of three internal components for the La Bonne Réponse team to manage their clients: (1) LBR-API - a robust multi-tenant REST API managing chat widgets, dual authentication (users and widgets), integrations with Stripe/AWS/Brevo, and automated quality control; (2) IA Factory - Back Office Admin where the team configures chatbots, generates custom widgets, manages knowledge bases and monitors conversations; (3) User Portal - where construction professionals access the AI assistant with conversation history and subscription management. The external link directs to the company's institutional website.",
				"myRole": "I served as Lead Front End and UI/UX Designer, responsible for the entire front-end architecture and development of both platforms (BO and Portal). I created all interface design and user experience, made technical decisions about stack and code patterns. I also actively collaborated on backend API development with the House of Coding team."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "RAG Tool", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "Multi-Tenant REST API",
					"description": "Robust REST API created by the House of Coding team using NestJS, specialized in AI chat widget management. I collaborated by implementing dashboard API calls, RAG tool integration and S3 document upload.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "RAG Integration", "description": "Connection with Retrieval-Augmented Generation tool for document-based responses"},
							{"name": "Multi-Tenancy", "description": "Complete data isolation per tenant with validated JWT"},
							{"name": "Dual Authentication", "description": "Separate JWT for users (admin, portal) and embedded widgets"},
							{"name": "Dynamic CORS", "description": "Origin validation based on widget integrations in database"},
							{"name": "Widget Management", "description": "Visual configurations (4 colors), logo, messages, Google Analytics"},
							{"name": "Reference System", "description": "Document upload, allowed/blocked URLs, automatic crawling"},
							{"name": "Quality Control", "description": "Verification points with Q&A, automatic validation via AI"},
							{"name": "Stripe Integration", "description": "Webhooks with signature validation, client management per tenant"},
							{"name": "S3 Upload", "description": "Presigned URLs for secure download with size limit"},
							{"name": "Rate Limiting", "description": "Custom throttler with 100 req/min per IP + user_id"},
							{"name": "CSV/Excel Import", "description": "Batch user import with validation and transaction"},
							{"name": "Auto Swagger", "description": "OpenAPI documentation generated via NestJS decorators"}
						]
					},
					"metrics": {
						"linesOfCode": "~15,000-20,000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "TypeORM repositories for data access abstraction"},
						{"name": "DTO Pattern", "description": "101 DTOs with class-validator for input validation"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard for access control"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext for context injection"},
						{"name": "Service Layer", "description": "Business logic isolated from controllers"},
						{"name": "Module Pattern", "description": "37 NestJS modules for feature organization"}
					],
					"decisions": [
						{"decision": "RAG Tool", "reason": "System for Retrieval-Augmented Generation, chosen for flexibility and control over the AI pipeline"},
						{"decision": "Dual JWT (Users + Widgets)", "reason": "Widgets embedded on external sites need their own authentication without exposing user credentials"},
						{"decision": "Dynamic CORS via Database", "reason": "Each widget can be embedded on multiple domains, impossible to configure static CORS"},
						{"decision": "Presigned URLs for S3", "reason": "Secure downloads without exposing AWS credentials, configurable expiration"},
						{"decision": "TypeORM over Prisma", "reason": "Better NestJS integration, decorator support, performance for complex queries"}
					],
					"challenges": [
						{"challenge": "Dynamic CORS for Widgets", "solution": "Database query to validate origin on each request, in-memory cache for performance"},
						{"challenge": "Stripe Webhook with Raw Body", "solution": "Custom middleware to preserve raw body before NestJS bodyParser"},
						{"challenge": "Batch User Import", "solution": "CSV/Excel parsing with fast-csv, batch validation, insert with transaction and rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "AI Chatbot Management Platform",
					"description": "Enterprise-grade admin dashboard. I created the UI/UX design, design system and entire component architecture. I developed multi-step forms, advanced tables, widget management, reference system and all other features except user, company and QA modules.",
					"features": {
						"frontend": [
							{"name": "Admin Dashboard", "description": "Complete platform management interface with metrics"},
							{"name": "Multi-Step Form", "description": "Widget creation in 7 steps with Zod validation per step"},
							{"name": "Section Editor", "description": "Accordion with independently saveable sections via PATCH"},
							{"name": "Widget Configurator", "description": "Real-time preview of chatbot customizations"},
							{"name": "Composed DataTable", "description": "Tables with TanStack Table: sorting, filters, pagination, batch selection"},
							{"name": "Knowledge Base UI", "description": "Drag-and-drop document upload with react-dropzone"},
							{"name": "QC System", "description": "Quality control with CSV/Excel import of verification points"},
							{"name": "Click Prompts Editor", "description": "Interface for creating clickable pre-configured prompts"},
							{"name": "Multi-tenant Management", "description": "User, company and role-based permission administration"},
							{"name": "Referentials System", "description": "Crawler monitoring with last execution and change detection"},
							{"name": "Cache Invalidation", "description": "Central function invalidating related queries in cascade"},
							{"name": "Conversation History", "description": "User conversation viewing with markdown rendering"},
							{"name": "Internationalization", "description": "Multi-language system with react-i18next for different language support"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32,000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals as compositions of sub-components"},
						{"name": "Custom Hooks", "description": "~40 hooks for reusable logic (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contexts for global state of multi-step forms"},
						{"name": "Optimistic Updates", "description": "React Query with optimistic mutations for reactive UX"},
						{"name": "Adapter Pattern", "description": "API data transformation to UI format"},
						{"name": "Feature-based Structure", "description": "Organization by features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context for UI state (forms), React Query for server state"},
						{"decision": "Accordion for editing", "reason": "Allows saving sections independently without blocking the user"}
					],
					"challenges": [
						{"challenge": "7-Step Form", "solution": "Context for global state, Zod validation per step, hasStepErrors() for visual feedback"},
						{"challenge": "Upload with Preview", "solution": "FileReader for immediate local preview, separate state for preview vs saved"},
						{"challenge": "Section Editing", "solution": "Accordion with Save button per section, PATCH for partial updates, track changes"},
						{"challenge": "Cascade Cache Invalidation", "solution": "refetchAllWidgetData() function invalidating related queries in correct order"}
					]
				},
				{
					"title": "User Portal",
					"subtitle": "Web Portal with Integrated Chat Widget",
					"description": "Complete application built from scratch. I implemented robust authentication, automatic token refresh, Stripe integration, chat widget in isolated iframe and complete refactoring from Webflow version.",
					"features": {
						"frontend": [
							{"name": "Automatic Token Refresh", "description": "JWT refresh 10 minutes before expiration, continuous rescheduling"},
							{"name": "Iframe Widget", "description": "Complete CSS/JS isolation with sandbox, postMessage communication"},
							{"name": "Stripe Integration", "description": "Embedded pricing table, status verification, billing portal"},
							{"name": "Authentication System", "description": "Login, registration, account activation, password reset with tokens"},
							{"name": "B2B and B2C Support", "description": "Differentiated subscription logic by tenant type"},
							{"name": "Conversation Management", "description": "Sidebar with conversation list, create new, continue existing"},
							{"name": "Presentation Pages", "description": "Dynamic URLs by name for demos without authentication"},
							{"name": "Account Management", "description": "Edit profile, professional title, sector, change password with robust validation"},
							{"name": "Internationalization", "description": "Multi-language system with react-i18next for different language support"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6,300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "JWT decoding + setTimeout for proactive refresh"},
						{"name": "Iframe Isolation", "description": "Widget in sandbox with postMessage communication"},
						{"name": "Route Guards", "description": "Route protection with authentication and subscription verification"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations for encapsulated logic"}
					],
					"decisions": [
						{"decision": "Iframe for Widget", "reason": "Complete CSS/JS isolation, avoids style conflicts with the portal"},
						{"decision": "Proactive Refresh", "reason": "Refresh 10min before avoids expiration during active use"},
						{"decision": "Stripe Pricing Table", "reason": "Embedded component eliminates need for custom UI for plans"},
						{"decision": "B2B without payment", "reason": "B2B companies have direct contract, no need for checkout"}
					],
					"challenges": [
						{"challenge": "Automatic Token Refresh", "solution": "Decode JWT to get expiration, setTimeout 10min before, reschedule after success"},
						{"challenge": "Isolated Iframe Widget", "solution": "Sandbox with allow-scripts allow-same-origin, parameters via query string, postMessage"},
						{"challenge": "Subscription Status", "solution": "useSubscription() hook with centralized logic for B2B (no payment) and B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Multi-Platform Ecosystem", "solution": "Modular architecture with shared API between BO and Portal, allowing independent evolution of each application"},
				{"challenge": "Authentication for Different Contexts", "solution": "Dual JWT system: one for authenticated users (admin/portal) and one for widgets embedded on external sites"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Professional Training Platforms",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "March 2025 - Present",
			"status": "In Production",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs is a French professional training organization that supports apprentices (apprenants) in their development journey. Each apprenant is accompanied by a tuteur who validates their missions and learning stages. The problem: fragmented pedagogical tracking in spreadsheets and emails, no centralized progress traceability, scattered manual assessments (PIX, Cléa, soft skills), and tutor-apprenant communication without organized history.",
				"solution": "The ecosystem consists of two complementary platforms: (1) LINK-Parcours - Enterprise-grade admin dashboard for training session management, users with 8 role levels, positioning assessments (PIX, Cléa, soft skills), and progress tracking (béabas, missions); (2) Tuto-Mission - Mobile-first PWA for real-time pedagogical monitoring, where tutors track apprenants through media-supported chat and stage validation.",
				"myRole": "In LINK-Parcours, I served as Lead Front End and UI/UX Designer, creating the entire admin interface design and implementing the complete system. In Tuto-Mission, I implemented the design received via Figma from House of Coding, developing advanced caching strategies to compensate for legacy API and create a fluid experience."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["PHP REST API (House of Coding team)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Training Admin Dashboard",
					"description": "Complete admin platform for training session management, users, and assessments. I created the entire UI/UX design and implemented the system with access control based on 8 role levels, server-side paginated tables, and complex forms with i18n validation.",
					"features": {
						"frontend": [
							{"name": "User Management", "description": "Full CRUD with 8 role levels (superAdmin to apprenant)"},
							{"name": "Session Management", "description": "Session creation with multiple days (session_jours) and participants"},
							{"name": "Positioning Assessment", "description": "PIX scores, Cléa results, soft skills games, interviews"},
							{"name": "Progress Tracking", "description": "Béabas and missions with global percentage calculation"},
							{"name": "Advanced Tables", "description": "TanStack Table with sorting, filters, server-side pagination"},
							{"name": "URL State Management", "description": "Filters persisted in URL via nuqs for sharing"},
							{"name": "Validated Forms", "description": "React Hook Form + Zod with i18n messages in French"},
							{"name": "Photo Upload", "description": "Drag & drop with preview and profile management"},
							{"name": "Dashboard with Charts", "description": "Visualizations with Recharts for metrics"},
							{"name": "Role System", "description": "RoleProtectedRoute + useRoleBasedRedirect for access control"},
							{"name": "Pre-registrations", "description": "Candidate management by training session"},
							{"name": "Internationalization", "description": "Multi-language system with react-i18next for different language support"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21,500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 hierarchical levels with RoleProtectedRoute and automatic redirection"},
						{"name": "Container/Presenter", "description": "Data hooks separated from table components"},
						{"name": "URL State Management", "description": "nuqs syncs filters/pagination with query parameters"},
						{"name": "Schema Validation", "description": "Dynamic Zod with i18n translations for error messages"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI with class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adapt API structure to UI format"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Increased productivity, integrated design system, automatic purge"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Accessible primitives without imposed styling, full control over appearance"},
						{"decision": "nuqs for URL state", "reason": "Automatic bidirectional sync, type-safe with parsers"},
						{"decision": "Hybrid Pagination", "reason": "Server-side for users/sessions (large volume), client-side for apprenants (fast filtering)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (fewer re-renders), native integration, better TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Role Levels", "solution": "UserGroupCode enum with hierarchical numeric codes, permission matrix per route"},
						{"challenge": "Persistent Filters", "solution": "URL state via nuqs + location.state for navigation context"},
						{"challenge": "Positioning System", "solution": "Dedicated components per type (PIX, Cléa, soft skills) + centralized usePositioning hook"},
						{"challenge": "Multi-Step Forms", "solution": "Tabs organizing sections, partial Zod schema per section, validation on submit"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "Pedagogical Monitoring PWA",
					"description": "Mobile-first application for real-time pedagogical monitoring. I implemented the design received via Figma, developing a chat system with media support, stage validation, and sophisticated caching strategy to compensate for legacy API.",
					"features": {
						"frontend": [
							{"name": "Chat System", "description": "Real-time messages tutor ↔ apprenant with persistent history"},
							{"name": "Media Upload", "description": "Photos and pedagogical videos with preview before sending"},
							{"name": "Stage Validation", "description": "Tuteur validates or requests redo with immediate visual feedback"},
							{"name": "Videos with Timestamps", "description": "React Player with stage-specific timestamps"},
							{"name": "Smart Auto-scroll", "description": "useScrollToBottom hook observes changes and executes scroll"},
							{"name": "Automatic Token Refresh", "description": "JWT refresh 10min before expiration, transparent to user"},
							{"name": "Multiple Apprenants", "description": "Auto-selection if tuteur has 1, selection page if N"},
							{"name": "Pedagogy Messages", "description": "Automatic system messages with differentiated styling"},
							{"name": "Optimistic Updates", "description": "Messages appear instantly before server confirmation"},
							{"name": "Performant Cache", "description": "Stale-while-revalidate for zero-latency navigation"},
							{"name": "Internationalization", "description": "Multi-language system with react-i18next for different language support"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4,200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centralizes auth logic with global variables"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulate data logic"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo per message type"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observes dependencies for auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wraps requests with JWT and token retry"},
						{"name": "Optimistic Updates", "description": "React Query with optimistic mutations and automatic rollback"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Automatic cache, mutations with optimistic updates, less boilerplate"},
						{"decision": "Pure CSS", "reason": "Small mobile-first project, performance without CSS-in-JS runtime"},
						{"decision": "localStorage + Cookies", "reason": "JWT in cookie for security, user data in localStorage for quick access"},
						{"decision": "Direct Upload via API", "reason": "Simpler architecture, backend controls validations"}
					],
					"challenges": [
						{"challenge": "Slow Legacy API", "solution": "Sophisticated cache: staleTime 5-10min, gcTime 30min, placeholderData for instant UX"},
						{"challenge": "Transparent Token Refresh", "solution": "Timer 10min before expiration + global handleTokenExpiration for 401 errors"},
						{"challenge": "Upload with Preview", "solution": "URL.createObjectURL() for local preview, separate text and media sending"},
						{"challenge": "Auto-scroll in Chat", "solution": "Custom hook observes [messages, isLoading] and executes scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Two Complementary Platforms", "solution": "Consistent architecture with React Query in both, reusable patterns"},
				{"challenge": "Shared Legacy PHP API", "solution": "Frontend caching strategies to create premium experience without backend modifications"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Abstraction Layer for IoT Devices",
			"role": "Backend Developer",
			"period": "November 2024 - Present",
			"status": "In Development",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell is a climate control company offering IoT devices (air conditioning, thermostats, sensors) controlled via mobile app. To connect devices from multiple manufacturers, the company used a third-party service acting as an intermediary. The problem: recurring licensing costs per device, vendor lock-in, additional latency, and inability to customize without depending on the supplier.",
				"solution": "Currently the company uses a third-party external API to connect devices, generating high monthly costs. The IoT Router is an abstraction layer that connects directly to manufacturer device APIs, normalizes different formats into a unified API, maintains compatibility with the legacy mobile app's expected format, and scales to support new manufacturers via a plugin system. The solution will eliminate these costs and give the company complete technological independence.",
				"myRole": "I took over a project started by an Amiltone colleague and performed a massive refactoring, defining best practices and adapting the architecture to scale. I designed the plugin architecture for multiple manufacturers, developed a distributed rate limiting system with Redis, and integrated AWS Lambda for scheduled commands. I also made interventions in Airwell's standard API server to integrate the IoT Router, and performed complete debugging of the React Native mobile app which wasn't working - identifying issues and sending reports to the team."
			},
			"stack": {
				"frontend": ["React Native (debugging + reports for Airwell team)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Multi-Manufacturer Plugin System + Scheduled Commands",
					"description": "Abstraction layer with plugin architecture for integration with multiple IoT manufacturers. Each manufacturer is an isolated module implementing a common interface. Includes scheduled command system via AWS Lambda + Bull Queue with automatic retry.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Extensible system where each manufacturer is an isolated plugin implementing IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Automatic device discovery per user per manufacturer with metadata extraction"},
							{"name": "Data Handler", "description": "Status reading, measurements (temperature, humidity, CO2) with unit normalization"},
							{"name": "Command Handler", "description": "Command execution (on/off, temperature adjustment) with automatic retry"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue for scheduled commands with exponential retry"},
							{"name": "OAuth 2.0 Flow", "description": "Complete authentication flow with automatic refresh of encrypted tokens"},
							{"name": "Rate Limiting", "description": "Sliding window algorithm in Redis with custom rules per manufacturer"},
							{"name": "Adapter Pattern", "description": "Data transformation from manufacturer format to normalized mobile-compatible format"},
							{"name": "Configuration as Code", "description": "Partner and device configuration via YAML validated by JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulating data access with optimized queries"},
							{"name": "Interceptors & Guards", "description": "Structured logging and consistent error handling throughout the application"}
						]
					},
					"metrics": {
						"linesOfCode": "~15,000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Manufacturers as isolated modules implementing common interface (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separation of responsibilities: specialized Discovery, Data, and Command handlers"},
						{"name": "Strategy Pattern", "description": "Each plugin implements its own authentication strategy (OAuth, API Key, proprietary)"},
						{"name": "Adapter Pattern", "description": "Normalization of heterogeneous data to single format compatible with legacy mobile"},
						{"name": "Queue Pattern", "description": "Bull Queue for scheduled commands with trigger/execution decoupling"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulating data access with centralized queries"},
						{"name": "Factory Pattern", "description": "Manufacturer-specific rate limit calculators with custom rules"},
						{"name": "Decorator Pattern", "description": "Interceptors and filters decorating operations with logging and error handling"}
					],
					"decisions": [
						{"decision": "Redis for Rate Limiting", "reason": "Distributed, persistent, precise sliding window, reused for Bull queues"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Already have Redis, monitoring UI (Bull Board), less latency than SQS"},
						{"decision": "AES-256-GCM in Database", "reason": "Operational simplicity vs dedicated Vault, sufficient for the use case"}
					],
					"challenges": [
						{"challenge": "Heterogeneous APIs", "solution": "Plugin pattern isolates complexity - each plugin speaks the manufacturer's 'language'"},
						{"challenge": "Complex Rate Limiting", "solution": "Per-manufacturer configuration + Redis sliding window + metrics for fine-tuning"},
						{"challenge": "Legacy Mobile Compatibility", "solution": "Adapter pattern normalizes responses to format expected by legacy app"},
						{"challenge": "Scheduled Commands", "solution": "AWS EventBridge → Lambda → Bull Queue with exponential retry and auditing"}
					]
				}
			],
			"challenges": [
				{"challenge": "Problematic Legacy Mobile Code (Biggest Challenge)", "solution": "Nothing was working - dirty code, no patterns, cascading errors. I performed complete debugging identifying 73 critical errors, refactored the backend to normalize data and minimize interventions in the chaotic legacy frontend"},
				{"challenge": "Replace Third-Party Service", "solution": "Plugin architecture enabled direct manufacturer integration while maintaining mobile compatibility"}
			]
		},
		"ragboost": {
			"title": "Ragboost",
			"subtitle": "Multi-Tenant SaaS AI Chatbots Platform",
			"role": "Full Stack Developer | Founder",
			"period": "October 2024 - Present",
			"status": "In Development (85%)",
			"client": "Personal Project",
			"overview": {
				"context": "The AI chatbot market is growing, but enterprise solutions are expensive for SMBs. Companies face high costs per message and storage, technical complexity to integrate RAG, generic widgets that don't represent the brand, lack of team collaboration, and isolated data that isn't leveraged. The opportunity: create an affordable alternative with advanced features for companies of all sizes.",
				"solution": "Development of a complete SaaS platform that democratizes access to AI chatbots with affordable pricing, simplifies assistant creation without coding, scales with robust multi-tenant architecture, and monetizes with flexible plans via Stripe. The platform allows companies to create virtual assistants contextualized with their own documents using RAG (Retrieval-Augmented Generation) technology, with team collaboration system featuring complete RBAC and support for 4 languages.",
				"myRole": "As founder and full stack developer, I designed and implemented the entire system architecture. On the backend, I developed Clean Architecture with Either Monad, Use Case Pattern, and Domain Events. On the frontend, I implemented TanStack Query with Optimistic Updates, cross-subdomain authentication system, and file-based routing with TanStack Router. I also did all UI/UX design and integrations with Stripe, open source RAG service, and email system."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "TanStack Router", "TanStack Query", "Tailwind CSS", "shadcn/ui", "Radix UI", "React Hook Form", "Zod", "i18next", "Recharts", "Axios", "Sonner", "Lucide React"],
				"backend": ["Fastify", "TypeScript", "Prisma", "PostgreSQL", "JWT", "bcryptjs", "Stripe", "Nodemailer", "Swagger", "Zod"]
			},
			"subProjects": [
				{
					"title": "Backend API",
					"subtitle": "Multi-Tenant REST API with Clean Architecture",
					"description": "Robust REST API with clean architecture, 10 domain modules, granular permissions system (RBAC) with 50+ permissions, Stripe integration for billing, and Domain Events for cross-module communication.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Clean Architecture", "description": "Layer separation: routes → controllers → use-cases → repositories → entities"},
							{"name": "Either Monad", "description": "Functional error handling with Either<Error, Success> in all use cases"},
							{"name": "Multi-Tenancy", "description": "Complete data isolation per tenant via subdomain with context middleware"},
							{"name": "Granular RBAC", "description": "50+ permissions across 4 role levels (owner, admin, curator, user)"},
							{"name": "Domain Events", "description": "Asynchronous communication between modules for decoupling"},
							{"name": "Webhook Service", "description": "Handlers for Stripe events (checkout, subscription, invoice) with signature verification"},
							{"name": "Factory Pattern", "description": "Manual dependency injection without container, easy to test and debug"},
							{"name": "Zod + OpenAPI", "description": "Schema validation with automatic Swagger documentation generation"},
							{"name": "Dual JWT", "description": "Access token (15min) + refresh token (7d) in httpOnly cookie"},
							{"name": "Rate Limiting", "description": "Endpoint protection with limits per IP and user"},
							{"name": "RAG Integration", "description": "Connection with open source service for document processing and semantic search"},
							{"name": "Invitation System", "description": "Email invitations with tracking, expiration and assignable roles"},
							{"name": "Subscription with Addons", "description": "Flexible Stripe plans system with modular addons (extra seats, storage, API calls)"},
							{"name": "Complete Billing", "description": "Checkout sessions, customer portal, invoices, proration, trial periods, cancellation"}
						]
					},
					"testing": [
						{"type": "Unit Tests", "description": "60+ files testing use cases and domain logic with 18+ In-Memory Repositories and 7 In-Memory Providers (hash, token, email, ragflow, stripe, etc.)", "tools": "Node.js Test Runner, In-Memory Repositories/Providers", "coverage": "Complete use cases"},
						{"type": "E2E Tests", "description": "40+ files testing controllers with Prisma Test Environment (isolated database), automatic plan seeding, unique data helpers (generateUniqueEmail, generateUniqueSlug)", "tools": "Node.js Test Runner, Prisma Test Environment, Supertest", "coverage": "All routes"}
					],
					"metrics": {
						"linesOfCode": "~52,000",
						"files": "200+",
						"modules": "10",
						"entities": "17"
					},
					"patterns": [
						{"name": "Either Monad Pattern", "description": "Either<L, R> with left() for errors and right() for success - type-safe errors"},
						{"name": "Use Case Pattern", "description": "Each business operation in isolated class with execute() returning Either"},
						{"name": "Factory Pattern", "description": "makeXxxUseCase() for manual DI - zero magic, tree-shakeable, easy debug"},
						{"name": "Controller Pattern", "description": "HTTP handlers that convert Either to appropriate status codes"},
						{"name": "Repository Pattern", "description": "Data access abstraction with Prisma - in-memory for tests"},
						{"name": "Provider Pattern", "description": "External services (email, payment, RAG) with interface + implementation"}
					],
					"decisions": [
						{"decision": "Fastify vs Express vs NestJS", "reason": "2x faster than Express, native schema validation, modular plugin system"},
						{"decision": "Either Monad vs throw/catch", "reason": "Type-safe errors, explicit flow, controller knows exactly what errors to expect"},
						{"decision": "Factory Pattern vs DI Container", "reason": "Zero magic, tree-shakeable, pure TypeScript without decorators, easy to test"},
						{"decision": "PostgreSQL + Prisma vs MongoDB", "reason": "ACID compliance, complex relations, type-safety, migrations, native RLS"}
					],
					"challenges": [
						{"challenge": "Multi-Tenant Isolation", "solution": "Middleware injects tenant context in all queries via X-Tenant-Subdomain header"},
						{"challenge": "50+ Granular Permissions", "solution": "Roles → permissions matrix, CheckPermissionUseCase reused in all use cases"},
						{"challenge": "Stripe Webhook with Raw Body", "solution": "Custom middleware to preserve raw body before Fastify bodyParser"},
						{"challenge": "Isolated E2E Tests", "solution": "Prisma test environment with isolated database, helpers to generate unique data"}
					]
				},
				{
					"title": "Frontend Dashboard",
					"subtitle": "React 19 SPA with Multi-Tenant via Subdomain",
					"description": "Administrative dashboard SPA with React 19 and TanStack Router. Cross-subdomain authentication system via cookies, sophisticated cache with TanStack Query, internationalization in 4 languages, and 31 shadcn/ui components.",
					"features": {
						"frontend": [
							{"name": "Multi-Tenant via Subdomain", "description": "Automatic tenant detection via hostname (tenant1.ragboost.app)"},
							{"name": "Cross-Subdomain Auth", "description": "Cookies shared between subdomains via Domain=.ragboost.app"},
							{"name": "TanStack Query Cache", "description": "staleTime, gcTime, refetchOnMount/WindowFocus configured per query"},
							{"name": "Optimistic Updates", "description": "onMutate → snapshot → rollback with instant feedback"},
							{"name": "File-Based Routing", "description": "TanStack Router with complete type-safety and beforeLoad for guards"},
							{"name": "Axios Interceptors", "description": "Automatic token refresh, retry with exponential backoff, i18n error handling"},
							{"name": "Frontend RBAC", "description": "useCurrentUserRole() with canManageTeam, canEditChatbots, etc."},
							{"name": "Validated Forms", "description": "React Hook Form + Zod with shared schemas frontend/backend"},
							{"name": "Design System", "description": "31 shadcn/ui + Radix UI components with Tailwind CSS 4"},
							{"name": "Complete i18n", "description": "4 languages (PT, EN, FR, ES) with lazy-loaded namespaces"},
							{"name": "Dashboard Analytics", "description": "Charts with Recharts for usage metrics"},
							{"name": "Team Management", "description": "Invitations, roles, member removal with optimistic updates"},
							{"name": "Subscription Management", "description": "Current plan view, addons, usage, upgrade/downgrade with Stripe Customer Portal"},
							{"name": "Addon Selector", "description": "Interface to add/remove addons (seats, storage, API calls) with price preview"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~19,500",
						"files": "206",
						"components": "88",
						"hooks": "7+",
						"pages": "15+"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "useChatbots, useTeamMembers, useAuth encapsulating data logic"},
						{"name": "Optimistic Updates Pattern", "description": "onMutate for snapshot, onError for rollback, onSuccess for invalidate"},
						{"name": "Provider Pattern", "description": "AuthProvider, TenantProvider for global state"},
						{"name": "API Queries Layer", "description": "Separation in /api/queries with barrel exports per feature"},
						{"name": "Subdomain Detection", "description": "getCurrentSubdomain() detects tenant in dev (lvh.me) and prod"},
						{"name": "Interceptor Pattern", "description": "Axios interceptors for token refresh and automatic retry"}
					],
					"decisions": [
						{"decision": "React 19 SPA vs Next.js", "reason": "Dashboard doesn't need SSR, Vite instant HMR, 10x faster builds"},
						{"decision": "TanStack Query vs Redux", "reason": "Automatic cache, mutations with optimistic updates, less boilerplate"},
						{"decision": "TanStack Router vs React Router", "reason": "Complete type-safety, file-based routing, beforeLoad for guards"},
						{"decision": "Cookie Auth vs localStorage", "reason": "Cross-subdomain sharing impossible with localStorage"}
					],
					"challenges": [
						{"challenge": "Cross-Subdomain Auth", "solution": "Cookie with Domain=.localhost (dev) / .ragboost.app (prod) shared between tenants"},
						{"challenge": "Transparent Token Refresh", "solution": "Interceptor detects 401, calls /refresh-token, retries original request"},
						{"challenge": "Complex State Management", "solution": "TanStack Query for server state, useCurrentTenant() for context, zero Redux"},
						{"challenge": "Multi-Environment Subdomain Detection", "solution": "Support for lvh.me (dev), localhost, and multisaas.app (prod) with same logic"}
					]
				}
			],
			"challenges": [
				{"challenge": "Complete Multi-Tenant SaaS Architecture", "solution": "Subdomain-based tenancy with data isolation, granular RBAC, integrated billing, and Domain Events for decoupling"},
				{"challenge": "Secure Cross-Subdomain Auth", "solution": "JWT in cookies with wildcard Domain, automatic token refresh, selective cache logout"}
			]
		},
		"va-beauty": {
			"title": "VA Beauty",
			"subtitle": "Showcase Website & Booking System",
			"role": "Full Stack Developer | UI/UX Designer",
			"period": "May - August 2025",
			"status": "In Production",
			"client": "VA Beauty",
			"overview": {
				"context": "VA Beauty is a boutique beauty institute in Aubagne, France, specializing in high-quality facial treatments and micropigmentation. The owner needed a digital presence that reflected the premium quality of her services. The problem: no online presence, manual phone/WhatsApp appointments, no visual portfolio to showcase results, and manual management of services and prices.",
				"solution": "Development of a complete professional showcase website with: (1) Premium landing page with service sections, before/after gallery and testimonials; (2) Booking system integrated with Cal.com with real-time calendar and Stripe payment; (3) Dynamic gallery supporting images, before/after and social media videos; (4) Blog managed via Sanity CMS for marketing content; (5) Admin panel for service and gallery management without technical knowledge.",
				"myRole": "I worked as Full Stack Developer and UI/UX Designer, creating the entire interface design from scratch and implementing the complete solution. I developed the architecture with Next.js 15 and React 19, integrated multiple external services (Supabase, Cal.com, Stripe, Cloudinary, Sanity), and built the admin panel for autonomous content management."
			},
			"stack": {
				"frontend": ["Next.js 15", "React 19", "TypeScript", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "Lucide React", "react-day-picker", "class-variance-authority"],
				"backend": ["Supabase (PostgreSQL + Auth + RLS)", "Stripe", "Cal.com", "Cloudinary", "Sanity CMS", "Vercel"]
			},
			"subProjects": [
				{
					"title": "Showcase Site & Booking",
					"subtitle": "Complete Online Booking Platform",
					"description": "Professional showcase website with integrated booking system. I created the entire UI/UX design and implemented premium landing page, service catalog, dynamic gallery, blog, and complete booking flow with payment.",
					"features": {
						"frontend": [
							{"name": "Premium Landing Page", "description": "Hero with gradient, trust indicators (500+ clients, 5★), service sections and testimonials"},
							{"name": "Service Catalog", "description": "Grid with 3 categories (Sourcils, Lèvres, Soins), combos/packages with prices"},
							{"name": "Before/After Gallery", "description": "Filter by category, media types (images, before/after, videos), full-screen modal"},
							{"name": "Multi-Step Booking Flow", "description": "4 steps: service selection → date/time → information → confirmation/payment"},
							{"name": "Cal.com Calendar", "description": "Embedded widget with real-time availability and automatic timezone"},
							{"name": "Embedded Videos", "description": "Support for Instagram, YouTube and TikTok with responsive embed"},
							{"name": "Integrated Blog", "description": "Articles managed via Sanity CMS with optimized SEO"},
							{"name": "Responsive Design", "description": "Mobile-first with Sora typography and gradient color system"}
						],
						"backend": [
							{"name": "Supabase Auth", "description": "Authentication with admin verification via admin_accounts table"},
							{"name": "Row Level Security", "description": "RLS policies for PostgreSQL data protection"},
							{"name": "Stripe Integration", "description": "Payments with Connected Accounts and bidirectional webhooks"},
							{"name": "Cal.com Integration", "description": "API for availability, booking creation and synchronization"},
							{"name": "Cloudinary Upload", "description": "Automatic image optimization, on-the-fly transformations, global CDN"},
							{"name": "Sanity CMS", "description": "Customizable studio for blog management with GROQ queries"},
							{"name": "Protected API Routes", "description": "Endpoints for booking, gallery, admin with validation and error handling"},
							{"name": "Protection Middleware", "description": "Next.js Middleware protecting /admin and /studio routes"}
						]
					},
					"metrics": {
						"linesOfCode": "~30,135",
						"files": "188",
						"components": "57",
						"pages": "32 API routes"
					},
					"patterns": [
						{"name": "App Router Pattern", "description": "Route groups, nested layouts, loading states with Next.js 15"},
						{"name": "Server/Client Components", "description": "Server Components for data fetching, Client for interactivity"},
						{"name": "Multi-Step Form Pattern", "description": "Centralized state with progressive steps and per-step validation"},
						{"name": "Provider Pattern", "description": "AuthProvider + SupabaseProvider for global authentication state"},
						{"name": "Middleware Protection", "description": "Admin verification at edge before loading protected pages"},
						{"name": "API Route Pattern", "description": "Isolated backend logic with consistent validation and error handling"}
					],
					"decisions": [
						{"decision": "Next.js 15 + React 19", "reason": "Server Components for performance, App Router for organization, Turbopack for fast builds"},
						{"decision": "Supabase vs Firebase", "reason": "Real PostgreSQL with SQL, native Row Level Security, integrated auth, open source, affordable pricing"},
						{"decision": "Cal.com vs Calendly", "reason": "Open source, flexible API, native Stripe integration, full customization, no forced branding"},
						{"decision": "Cloudinary vs S3", "reason": "Automatic image optimization, on-the-fly transformations, global CDN included, generous free tier"},
						{"decision": "Sanity vs Contentful", "reason": "Customizable studio, powerful GROQ query language, real-time collaboration, generous free tier"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste not dependency, full customization, accessibility via Radix, smaller bundle, native Tailwind"}
					],
					"challenges": [
						{"challenge": "Cal.com + Stripe Integration", "solution": "Stripe Connected Account, bidirectional webhooks (Cal → App, Stripe → App), diagnostic endpoints for debug"},
						{"challenge": "Multi-Media Gallery", "solution": "Flexible schema with type discriminator, MediaModal component detecting type, responsive video embed"},
						{"challenge": "Admin Access Control", "solution": "admin_accounts table with JSONB permissions, is_active flag, super-admin fallback, RLS policies"},
						{"challenge": "SEO for Dynamic Services", "solution": "generateMetadata in each page, JSON-LD structured data, dynamic sitemap, required alt text"},
						{"challenge": "Performance with Many Images", "solution": "Next.js Image with lazy loading, Cloudinary for optimization, blur placeholder, responsive sizes"}
					]
				}
			],
			"challenges": [
				{"challenge": "Multiple External Integrations", "solution": "Modular architecture with separate providers for each service (Supabase, Cal.com, Stripe, Cloudinary, Sanity), robust webhooks with retry"},
				{"challenge": "Complex Booking Flow", "solution": "Multi-step form with centralized state, progressive validation, seamless integration between Cal.com and Stripe"}
			]
		},
		"sncf-util-ia": {
			"title": "SNCF IA Reseau",
			"subtitle": "Intelligent Assistance Platform for Railway Network",
			"role": "Full Stack Developer",
			"period": "October - December 2024",
			"status": "Production",
			"client": "SNCF (Société Nationale des Chemins de fer Français)",
			"overview": {
				"context": "SNCF needed an internal platform to optimize support for employees in the Utilité area, providing instant answers about procedures, regulations, and technical information about the railway network through artificial intelligence.",
				"solution": "Complete system with robust REST API in NestJS and modern web interface in React. Integration with Chatbase AI for question processing, JWT authentication system, and administrative panel for user management and conversation monitoring.",
				"myRole": "I worked as a Full Stack Developer responsible for all project development. I developed the entire backend API architecture with NestJS, TypeORM, and MySQL, and fully implemented the frontend in React, including all animations and interactions. Only the UI/UX design was provided by the House of Coding team via Figma."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Tailwind CSS", "shadcn/ui", "Radix UI", "React Router DOM", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "Recharts", "Sonner", "Lucide React"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "Chatbase AI", "class-validator", "class-transformer", "bcrypt", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "SNCF IA Reseau API",
					"subtitle": "NestJS Backend for Conversation and User Management",
					"description": "Robust REST API developed in NestJS with modular architecture. Complete JWT authentication system, integration with Chatbase AI for question processing, user management with different permission levels, and conversation monitoring.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "JWT Authentication", "description": "Complete system with register/login, refresh tokens, protection guards and Passport strategy"},
							{"name": "Chatbase AI Integration", "description": "Proxy for Chatbase API with conversation management, history and rate limiting"},
							{"name": "User Management", "description": "Complete CRUD with profiles (USER, ADMIN, SUPER_ADMIN), soft delete and robust validations"},
							{"name": "Conversation Monitoring", "description": "Complete conversation history with filters, pagination and statistics"},
							{"name": "Statistics API", "description": "Dashboard with usage metrics, conversations by period and active user analysis"},
							{"name": "Structured Logs", "description": "Logging system with Winston for debugging and auditing"},
							{"name": "Swagger/OpenAPI", "description": "Automatic and interactive API documentation with examples"},
							{"name": "Docker Setup", "description": "Complete containerization with MySQL, persistent volumes and isolated network"}
						]
					},
					"metrics": {
						"linesOfCode": "~8,500",
						"files": "67",
						"modules": "7",
						"entities": "3",
						"dtos": "15+"
					},
					"patterns": [
						{"name": "Modular Architecture", "description": "Separation into modules (Auth, Users, Conversations, Stats, Chatbase) with well-defined responsibilities"},
						{"name": "Repository Pattern", "description": "TypeORM repositories for data access abstraction"},
						{"name": "DTO Pattern", "description": "Data Transfer Objects with class-validator for input/output validation"},
						{"name": "Guard Pattern", "description": "Custom guards for JWT authentication and role verification"},
						{"name": "Exception Filters", "description": "Centralized error handling with HttpException"},
						{"name": "Dependency Injection", "description": "NestJS native dependency injection for testability"}
					],
					"decisions": [
						{"decision": "NestJS vs Express/Fastify", "reason": "Enterprise-ready structure out-of-the-box, TypeScript first-class, scalable modular architecture, decorators for metaprogramming, native Swagger integration"},
						{"decision": "TypeORM vs Prisma", "reason": "Decorators for entities, robust migrations, multiple database support, familiar active record pattern, better for complex NestJS projects"},
						{"decision": "JWT vs Session", "reason": "Stateless, horizontally scalable, no server-side storage required, ideal for REST APIs, refresh tokens for security"},
						{"decision": "Chatbase vs OpenAI Direct", "reason": "Managed conversation system, specific model training, included rate limiting, built-in metrics, optimized cost"},
						{"decision": "Winston vs Console", "reason": "Structured logs, multiple transports (file, console), configurable levels, automatic rotation, essential for production"}
					],
					"challenges": [
						{"challenge": "Chatbase Rate Limiting", "solution": "Request queue implementation with exponential retry, frequent response cache, fallback messages for timeouts"},
						{"challenge": "JWT Token Management", "solution": "Refresh tokens with rotation, blacklist for revoked tokens, configurable expiration per environment"},
						{"challenge": "Conversation Persistence", "solution": "Optimized schema with indexes, 1:N User-Conversation relationship, soft delete for auditing"},
						{"challenge": "Data Validation", "solution": "DTOs with class-validator, global transform pipes, custom validators for business rules"},
						{"challenge": "Docker Development", "solution": "Docker Compose with hot-reload, volumes for MySQL persistence, isolated network, secure environment variables"}
					],
					"testing": [
						{"type": "Documentation", "description": "Complete Swagger with all documented endpoints", "tools": "@nestjs/swagger"},
						{"type": "Logs", "description": "Structured logging system for debugging and auditing", "tools": "Winston"}
					]
				},
				{
					"title": "SNCF IA Reseau Front",
					"subtitle": "Modern Web Interface with Intelligent Chat",
					"description": "React single-page application with design provided by the House of Coding team via Figma. Modern interface with real-time chat, complete administrative panel, and integrated authentication system. Animations and interactions developed by me.",
					"features": {
						"frontend": [
							{"name": "Chat Interface", "description": "Real-time conversational interface with history, typing indicators and markdown rendering"},
							{"name": "Authentication", "description": "Login/register with validation, session persistence, automatic token refresh"},
							{"name": "Administrative Panel", "description": "Dashboard with statistics, user management, conversation viewing and analytics"},
							{"name": "User Management", "description": "Complete CRUD, advanced filters, roles and permissions, data export"},
							{"name": "Conversation History", "description": "Detailed view of all conversations with filters by date, user and content"},
							{"name": "Notification System", "description": "Toasts with Sonner for action feedback and errors"},
							{"name": "Interactive Tables", "description": "TanStack Table with sorting, filtering, pagination and column visibility"},
							{"name": "Validated Forms", "description": "React Hook Form + Zod for robust and type-safe validation"},
							{"name": "Custom Animations", "description": "Smooth transitions, micro-interactions and loading states developed by me"},
							{"name": "Responsive Design", "description": "Adaptive layout for desktop, tablet and mobile based on House of Coding's Figma"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~12,000",
						"files": "95",
						"components": "48",
						"hooks": "12",
						"pages": "8"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "Reusable hooks for auth, API calls, form management and state"},
						{"name": "React Query Pattern", "description": "Optimized cache, automatic invalidation, optimistic updates, error handling"},
						{"name": "Form Management", "description": "React Hook Form + Zod for type-safe validation and performance"},
						{"name": "Route Protection", "description": "Private routes with automatic redirect based on auth state"},
						{"name": "Component Composition", "description": "shadcn/ui components customizable via props and slots"},
						{"name": "State Management", "description": "React Query for server state, Context API for global UI state"}
					],
					"decisions": [
						{"decision": "React vs Next.js", "reason": "Pure SPA without SSR need, client-side authentication, simpler deployment, sufficient client-side routing"},
						{"decision": "TanStack Query vs Redux", "reason": "Specialized in server state, intelligent cache, less boilerplate, automatic invalidation, excellent devtools"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste without heavy dependencies, full customization via Tailwind, Radix accessibility, modern components"},
						{"decision": "React Hook Form + Zod", "reason": "Superior performance (fewer re-renders), type-safe validation, perfect integration, smaller bundle than Formik"},
						{"decision": "Recharts vs Chart.js", "reason": "Composable, declarative with React, customization via props, native TypeScript, responsive out-of-the-box"}
					],
					"challenges": [
						{"challenge": "Figma Design Implementation", "solution": "Pixel-perfect fidelity to House of Coding's design using Tailwind, consistent color and spacing system, reusable components"},
						{"challenge": "Custom Animations", "solution": "Custom CSS transitions, framer-motion for complex animations, loading skeletons, micro-interactions on buttons and cards"},
						{"challenge": "Real-time Chat Experience", "solution": "Optimized polling with React Query, intelligent auto-scroll, typing indicators, markdown formatting"},
						{"challenge": "Token Management", "solution": "Axios interceptor for automatic refresh, failed request retry, logout on expired token"},
						{"challenge": "Performant Tables", "solution": "Virtualization with TanStack Table, server-side pagination, lazy loading, cell memoization"}
					]
				}
			]
		}
	}
}
