{
	"backToProjects": "Retour aux projets",
	"visitProject": "Visiter le projet",
	"role": "Rôle",
	"period": "Période",
	"status": "Statut",
	"client": "Client",
	"overview": {
		"title": "Aperçu",
		"context": "Contexte",
		"solution": "Solution",
		"myRole": "Mon Rôle"
	},
	"stack": {
		"title": "Stack Technique",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Fonctionnalités"
	},
	"challenges": {
		"title": "Défis & Solutions"
	},
	"metrics": {
		"title": "Métriques",
		"linesOfCode": "Lignes de Code",
		"files": "Fichiers",
		"modules": "Modules",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Composants",
		"hooks": "Hooks",
		"pages": "Pages"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Décisions Techniques",
		"decision": "Décision",
		"reason": "Justification"
	},
	"testing": {
		"title": "Stratégie de Tests",
		"type": "Type",
		"tools": "Outils",
		"coverage": "Couverture"
	},
	"gallery": {
		"title": "Galerie"
	},
	"subProjects": "Projets",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Écosystème IA pour le Secteur de la Construction",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Avril 2025 - Présent",
			"status": "En Production",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse est une startup française qui révolutionne le secteur de la construction et de la rénovation énergétique grâce à l'IA Générative. Le problème : les professionnels du bâtiment doivent vérifier la conformité avec plus de 300 réglementations techniques françaises (DTU, normes NF, Eurocodes, etc.), un processus manuel chronophage et sujet aux erreurs. La solution : un assistant IA spécifiquement formé sur ces réglementations, répondant instantanément aux questions techniques en citant les sources officielles.",
				"solution": "L'écosystème se compose de trois composants internes pour que l'équipe La Bonne Réponse gère ses clients : (1) LBR-API - API REST multi-tenant robuste gérant les widgets de chat, l'authentification double (utilisateurs et widgets), les intégrations avec Stripe/AWS/Brevo, et le contrôle qualité automatisé ; (2) IA Factory - Back Office Admin où l'équipe configure les chatbots, génère des widgets personnalisés, gère les bases de connaissances et surveille les conversations ; (3) Portail Utilisateur - où les professionnels du bâtiment accèdent à l'assistant IA avec historique des conversations et gestion des abonnements. Le lien externe redirige vers le site institutionnel de l'entreprise.",
				"myRole": "J'ai occupé le rôle de Lead Front End et UI/UX Designer, responsable de toute l'architecture et du développement front-end des deux plateformes (BO et Portail). J'ai créé tout le design d'interface et l'expérience utilisateur, pris des décisions techniques sur le stack et les patterns de code. J'ai également collaboré activement au développement de l'API backend avec l'équipe House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Outil RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robuste créée par l'équipe House of Coding utilisant NestJS, spécialisée dans la gestion de widgets de chat avec IA. J'ai collaboré en implémentant les appels API du dashboard, l'intégration avec l'outil RAG et l'upload de documents sur S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Intégration RAG", "description": "Connexion avec outil de Retrieval-Augmented Generation pour réponses basées sur documents"},
							{"name": "Multi-Tenancy", "description": "Isolation complète des données par tenant avec JWT validé"},
							{"name": "Authentification Double", "description": "JWT séparé pour utilisateurs (admin, portail) et widgets embarqués"},
							{"name": "CORS Dynamique", "description": "Validation d'origine basée sur widget integrations en base"},
							{"name": "Gestion des Widgets", "description": "Configurations visuelles (4 couleurs), logo, messages, Google Analytics"},
							{"name": "Système de Références", "description": "Upload de documents, URLs autorisées/bloquées, crawling automatique"},
							{"name": "Contrôle Qualité", "description": "Points de vérification avec questions/réponses, validation automatique via IA"},
							{"name": "Intégration Stripe", "description": "Webhooks avec validation de signature, gestion clients par tenant"},
							{"name": "Upload S3", "description": "URLs présignées pour téléchargement sécurisé avec limite de taille"},
							{"name": "Rate Limiting", "description": "Throttler personnalisé avec 100 req/min par IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importation en lot d'utilisateurs avec validation et transaction"},
							{"name": "Swagger Automatique", "description": "Documentation OpenAPI générée via décorateurs NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "Repositories TypeORM pour abstraction d'accès aux données"},
						{"name": "DTO Pattern", "description": "101 DTOs avec class-validator pour validation d'entrée"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard pour contrôle d'accès"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext pour injection de contexte"},
						{"name": "Service Layer", "description": "Logique métier isolée des controllers"},
						{"name": "Module Pattern", "description": "37 modules NestJS pour organisation des features"}
					],
					"decisions": [
						{"decision": "Outil RAG", "reason": "Système pour Retrieval-Augmented Generation, choisi pour la flexibilité et le contrôle sur le pipeline IA"},
						{"decision": "JWT Double (Utilisateurs + Widgets)", "reason": "Widgets embarqués sur sites externes nécessitent authentification propre, sans exposer credentials utilisateurs"},
						{"decision": "CORS Dynamique via Base", "reason": "Chaque widget peut être embarqué sur plusieurs domaines, impossible de configurer CORS statique"},
						{"decision": "URLs Présignées pour S3", "reason": "Téléchargements sécurisés sans exposer credentials AWS, expiration configurable"},
						{"decision": "TypeORM plutôt que Prisma", "reason": "Meilleure intégration NestJS, support décorateurs, performance pour queries complexes"}
					],
					"challenges": [
						{"challenge": "CORS Dynamique pour Widgets", "solution": "Query en base pour valider origine à chaque requête, cache mémoire pour performance"},
						{"challenge": "Webhook Stripe avec Raw Body", "solution": "Middleware personnalisé pour préserver raw body avant bodyParser NestJS"},
						{"challenge": "Import en Lot d'Utilisateurs", "solution": "Parsing CSV/Excel avec fast-csv, validation en lot, insert avec transaction et rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plateforme de Gestion de Chatbots IA",
					"description": "Dashboard administratif enterprise-grade. J'ai créé le design UI/UX, design system et toute l'architecture des composants. J'ai développé les formulaires multi-étapes, tables avancées, gestion des widgets, système de références et toutes les autres fonctionnalités sauf les modules utilisateurs, entreprises et QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administratif", "description": "Interface complète pour la gestion de la plateforme avec métriques"},
							{"name": "Formulaire Multi-Étapes", "description": "Création de widget en 7 étapes avec validation Zod par étape"},
							{"name": "Éditeur par Sections", "description": "Accordion avec sections enregistrables indépendamment via PATCH"},
							{"name": "Widget Configurator", "description": "Prévisualisation en temps réel des personnalisations du chatbot"},
							{"name": "DataTable Composée", "description": "Tables avec TanStack Table : tri, filtres, pagination, sélection batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documents avec react-dropzone"},
							{"name": "Système de QC", "description": "Contrôle qualité avec import CSV/Excel de points de vérification"},
							{"name": "Click Prompts Editor", "description": "Interface pour créer des prompts pré-configurés cliquables"},
							{"name": "Gestion Multi-tenant", "description": "Administration des utilisateurs, entreprises et permissions par rôle"},
							{"name": "Système de Referentials", "description": "Surveillance du crawler avec dernière exécution et détection des changements"},
							{"name": "Cache Invalidation", "description": "Fonction centrale invalidant les queries liées en cascade"},
							{"name": "Historique des Conversations", "description": "Visualisation des conversations utilisateurs avec rendu markdown"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals comme compositions de sous-composants"},
						{"name": "Custom Hooks", "description": "~40 hooks pour logique réutilisable (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextes pour état global des formulaires multi-étapes"},
						{"name": "Optimistic Updates", "description": "React Query avec mutations optimistes pour UX réactive"},
						{"name": "Adapter Pattern", "description": "Transformation données API vers format UI"},
						{"name": "Feature-based Structure", "description": "Organisation par features : /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context pour état UI (formulaires), React Query pour état serveur"},
						{"decision": "Accordion pour édition", "reason": "Permet sauvegarder sections indépendamment sans bloquer l'utilisateur"}
					],
					"challenges": [
						{"challenge": "Formulaire de 7 Étapes", "solution": "Context pour état global, validation Zod par étape, hasStepErrors() pour feedback visuel"},
						{"challenge": "Upload avec Prévisualisation", "solution": "FileReader pour prévisualisation locale immédiate, état séparé pour preview vs saved"},
						{"challenge": "Édition par Sections", "solution": "Accordion avec bouton Save par section, PATCH pour updates partiels, track changes"},
						{"challenge": "Cache Invalidation en Cascade", "solution": "Fonction refetchAllWidgetData() invalidant queries liées dans le bon ordre"}
					]
				},
				{
					"title": "Portail Utilisateur",
					"subtitle": "Portail Web avec Widget de Chat Intégré",
					"description": "Application complète construite de zéro. J'ai implémenté authentification robuste, refresh automatique de tokens, intégration Stripe, widget de chat en iframe isolé et refonte complète de la version Webflow.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automatique", "description": "Refresh JWT 10 minutes avant expiration, replanification continue"},
							{"name": "Widget en Iframe", "description": "Isolation complète CSS/JS avec sandbox, communication via postMessage"},
							{"name": "Intégration Stripe", "description": "Pricing table intégrée, vérification de statut, billing portal"},
							{"name": "Système d'Authentification", "description": "Connexion, inscription, activation de compte, reset de mot de passe"},
							{"name": "Support B2B et B2C", "description": "Logique de souscription différenciée par type de tenant"},
							{"name": "Gestion des Conversations", "description": "Sidebar avec liste de conversations, créer nouvelle, continuer existante"},
							{"name": "Pages de Présentation", "description": "URLs dynamiques par nom pour démos sans authentification"},
							{"name": "Gestion de Compte", "description": "Modifier profil, titre professionnel, secteur, changer mot de passe"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Décodage JWT + setTimeout pour refresh proactif"},
						{"name": "Iframe Isolation", "description": "Widget en sandbox avec communication via postMessage"},
						{"name": "Route Guards", "description": "Protection des routes avec vérification authentification et souscription"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations pour logique encapsulée"}
					],
					"decisions": [
						{"decision": "Iframe pour Widget", "reason": "Isolation complète CSS/JS, évite conflits de style avec le portail"},
						{"decision": "Refresh Proactif", "reason": "Refresh 10min avant évite expiration pendant utilisation active"},
						{"decision": "Stripe Pricing Table", "reason": "Composant embarqué élimine besoin d'UI personnalisée pour plans"},
						{"decision": "B2B sans paiement", "reason": "Entreprises B2B ont contrat direct, pas besoin de checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automatique", "solution": "Décoder JWT pour obtenir expiration, setTimeout 10min avant, replanifier après succès"},
						{"challenge": "Widget en Iframe Isolé", "solution": "Sandbox avec allow-scripts allow-same-origin, paramètres via query string, postMessage"},
						{"challenge": "Statut de Souscription", "solution": "Hook useSubscription() avec logique centralisée pour B2B (sans paiement) et B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Écosystème Multi-Plateforme", "solution": "Architecture modulaire avec API partagée entre BO et Portail, permettant évolution indépendante de chaque application"},
				{"challenge": "Authentification pour Contextes Différents", "solution": "Système JWT double : un pour utilisateurs authentifiés (admin/portail) et un pour widgets embarqués sur sites externes"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plateformes de Formation Professionnelle",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Mars 2025 - Présent",
			"status": "En Production",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs est un organisme de formation professionnelle français qui accompagne les apprenants dans leur parcours de développement. Chaque apprenant est accompagné par un tuteur qui valide ses missions et étapes d'apprentissage. Le problème : un suivi pédagogique fragmenté dans des tableurs et emails, sans traçabilité centralisée du progrès, des évaluations manuelles dispersées (PIX, Cléa, soft skills), et une communication tuteur-apprenant sans historique organisé.",
				"solution": "L'écosystème se compose de deux plateformes complémentaires : (1) LINK-Parcours - Dashboard administratif enterprise-grade pour la gestion des sessions de formation, des utilisateurs avec 8 niveaux de rôles, des évaluations de positionnement (PIX, Cléa, soft skills), et le suivi de progression (béabas, missions) ; (2) Tuto-Mission - PWA mobile-first pour l'accompagnement pédagogique en temps réel, où les tuteurs suivent les apprenants via chat avec support média et validation d'étapes.",
				"myRole": "Sur LINK-Parcours, j'ai occupé le rôle de Lead Front End et UI/UX Designer, créant tout le design de l'interface administrative et implémentant le système complet. Sur Tuto-Mission, j'ai implémenté le design reçu via Figma de House of Coding, développant des stratégies de cache avancées pour compenser l'API legacy et créer une expérience fluide."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (équipe House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administratif de Formation",
					"description": "Plateforme administrative complète pour la gestion des sessions de formation, des utilisateurs et des évaluations. J'ai créé tout le design UI/UX et implémenté le système avec un contrôle d'accès basé sur 8 niveaux de rôles, des tables paginées côté serveur, et des formulaires complexes avec validation i18n.",
					"features": {
						"frontend": [
							{"name": "Gestion des Utilisateurs", "description": "CRUD complet avec 8 niveaux de rôles (superAdmin jusqu'à apprenant)"},
							{"name": "Gestion des Sessions", "description": "Création de sessions avec plusieurs jours (session_jours) et participants"},
							{"name": "Évaluation de Positionnement", "description": "Scores PIX, résultats Cléa, soft skills games, entretiens"},
							{"name": "Suivi de Progression", "description": "Béabas et missions avec calcul de pourcentage global"},
							{"name": "Tables Avancées", "description": "TanStack Table avec tri, filtres, pagination côté serveur"},
							{"name": "URL State Management", "description": "Filtres persistés dans l'URL via nuqs pour le partage"},
							{"name": "Formulaires Validés", "description": "React Hook Form + Zod avec messages i18n en français"},
							{"name": "Upload de Photo", "description": "Drag & drop avec preview et gestion de profil"},
							{"name": "Dashboard avec Graphiques", "description": "Visualisations avec Recharts pour les métriques"},
							{"name": "Système de Rôles", "description": "RoleProtectedRoute + useRoleBasedRedirect pour le contrôle d'accès"},
							{"name": "Pré-inscriptions", "description": "Gestion des candidats par session de formation"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 niveaux hiérarchiques avec RoleProtectedRoute et redirection automatique"},
						{"name": "Container/Presenter", "description": "Hooks de données séparés des composants de table"},
						{"name": "URL State Management", "description": "nuqs synchronise filtres/pagination avec les query parameters"},
						{"name": "Schema Validation", "description": "Zod dynamique avec traductions i18n pour les messages d'erreur"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI avec class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Les hooks adaptent la structure API au format UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Productivité accrue, design system intégré, purge automatique"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives accessibles sans styling imposé, contrôle total sur l'apparence"},
						{"decision": "nuqs pour URL state", "reason": "Synchronisation bidirectionnelle automatique, type-safe avec parsers"},
						{"decision": "Pagination Hybride", "reason": "Côté serveur pour users/sessions (grand volume), côté client pour apprenants (filtrage rapide)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (moins de re-renders), intégration native, meilleur TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Niveaux de Rôles", "solution": "Enum UserGroupCode avec codes numériques hiérarchiques, matrice de permissions par route"},
						{"challenge": "Filtres Persistants", "solution": "État dans l'URL via nuqs + location.state pour le contexte de navigation"},
						{"challenge": "Système de Positionnement", "solution": "Composants dédiés par type (PIX, Cléa, soft skills) + hook usePositioning centralisé"},
						{"challenge": "Formulaires Multi-Étapes", "solution": "Tabs organisant les sections, schéma Zod partiel par section, validation à la soumission"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA d'Accompagnement Pédagogique",
					"description": "Application mobile-first pour l'accompagnement pédagogique en temps réel. J'ai implémenté le design reçu via Figma, développant un système de chat avec support média, validation d'étapes, et une stratégie de cache sophistiquée pour compenser l'API legacy.",
					"features": {
						"frontend": [
							{"name": "Système de Chat", "description": "Messages en temps réel tuteur ↔ apprenant avec historique persistant"},
							{"name": "Upload de Médias", "description": "Photos et vidéos pédagogiques avec preview avant envoi"},
							{"name": "Validation d'Étapes", "description": "Le tuteur valide ou demande une reprise avec feedback visuel immédiat"},
							{"name": "Vidéos avec Timestamps", "description": "Lecteur React Player avec timestamps spécifiques par étape"},
							{"name": "Auto-scroll Intelligent", "description": "Hook useScrollToBottom observe les changements et exécute le scroll"},
							{"name": "Token Refresh Automatique", "description": "Refresh JWT 10min avant l'expiration, transparent pour l'utilisateur"},
							{"name": "Multiples Apprenants", "description": "Sélection automatique si le tuteur en a 1, page de sélection si N"},
							{"name": "Messages de Pédagogie", "description": "Messages automatiques du système avec stylisation différenciée"},
							{"name": "Optimistic Updates", "description": "Les messages apparaissent instantanément avant la confirmation du serveur"},
							{"name": "Cache Performant", "description": "Stale-while-revalidate pour une navigation zéro-latence"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centralise la logique d'authentification avec variables globales"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulent la logique de données"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo par type de message"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observe les dépendances pour l'auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrappe les requêtes avec JWT et retry de token"},
						{"name": "Optimistic Updates", "description": "React Query avec mutations optimistes et rollback automatique"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automatique, mutations avec optimistic updates, moins de boilerplate"},
						{"decision": "CSS Pur", "reason": "Projet mobile-first petit, performance sans runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT en cookie pour la sécurité, données utilisateur en localStorage pour un accès rapide"},
						{"decision": "Upload Direct via API", "reason": "Architecture plus simple, le backend contrôle les validations"}
					],
					"challenges": [
						{"challenge": "API Legacy Lente", "solution": "Cache sophistiqué : staleTime 5-10min, gcTime 30min, placeholderData pour UX instantanée"},
						{"challenge": "Refresh de Token Transparent", "solution": "Timer 10min avant expiration + handleTokenExpiration global pour erreurs 401"},
						{"challenge": "Upload avec Preview", "solution": "URL.createObjectURL() pour preview local, envoi séparé de texte et média"},
						{"challenge": "Scroll Automatique en Chat", "solution": "Hook customisé observe [messages, isLoading] et exécute scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Deux Plateformes Complémentaires", "solution": "Architecture cohérente avec React Query dans les deux, patterns réutilisables"},
				{"challenge": "API PHP Legacy Partagée", "solution": "Stratégies de cache côté frontend pour créer une expérience premium sans modifier le backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Couche d'Abstraction pour Appareils IoT",
			"role": "Backend Developer",
			"period": "Novembre 2024 - Présent",
			"status": "En Développement",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell est une entreprise de climatisation proposant des appareils IoT (climatiseurs, thermostats, capteurs) contrôlés via application mobile. Pour connecter les appareils de plusieurs fabricants, l'entreprise utilisait un service tiers comme intermédiaire. Le problème : coûts récurrents de licence par appareil, vendor lock-in, latence supplémentaire, et impossibilité de personnaliser sans dépendre du fournisseur.",
				"solution": "Actuellement l'entreprise utilise une API externe tierce pour connecter les appareils, générant des coûts mensuels élevés. L'IoT Router est une couche d'abstraction qui se connecte directement aux APIs des fabricants d'appareils, normalise les différents formats en une API unifiée, maintient la compatibilité avec le format attendu par le mobile legacy, et permet d'ajouter de nouveaux fabricants via un système de plugins. La solution va éliminer ces coûts et donner une indépendance technologique totale à l'entreprise.",
				"myRole": "J'ai repris un projet initié par un collègue d'Amiltone et réalisé un refactoring massif, définissant les bonnes pratiques et adaptant l'architecture pour scaler. J'ai conçu l'architecture de plugins pour plusieurs fabricants, développé un système de rate limiting distribué avec Redis, et intégré AWS Lambda pour les commandes planifiées. J'ai également fait des interventions sur l'API server standard d'Airwell pour intégrer l'IoT Router, et réalisé un debugging complet de l'app mobile React Native qui ne fonctionnait pas - identifiant les problèmes et envoyant des rapports à l'équipe."
			},
			"stack": {
				"frontend": ["React Native (debugging + rapports pour équipe Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Système de Plugins Multi-Fabricant + Commandes Planifiées",
					"description": "Couche d'abstraction avec architecture de plugins pour l'intégration avec plusieurs fabricants IoT. Chaque fabricant est un module isolé implémentant une interface commune. Inclut système de commandes planifiées via AWS Lambda + Bull Queue avec retry automatique.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Système extensible où chaque fabricant est un plugin isolé implémentant IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Découverte automatique des appareils par utilisateur et fabricant avec extraction de métadonnées"},
							{"name": "Data Handler", "description": "Lecture de statut, mesures (température, humidité, CO2) avec normalisation des unités"},
							{"name": "Command Handler", "description": "Exécution de commandes (on/off, ajustement température) avec retry automatique"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue pour commandes planifiées avec retry exponentiel"},
							{"name": "OAuth 2.0 Flow", "description": "Flux d'authentification complet avec refresh automatique des tokens chiffrés"},
							{"name": "Rate Limiting", "description": "Algorithme sliding window dans Redis avec règles personnalisées par fabricant"},
							{"name": "Adapter Pattern", "description": "Transformation des données du format fabricant vers format normalisé compatible mobile"},
							{"name": "Configuration as Code", "description": "Configuration des partenaires et appareils via YAML validé par JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulant l'accès aux données avec queries optimisées"},
							{"name": "Interceptors & Guards", "description": "Logging structuré et gestion d'erreurs cohérente dans toute l'application"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricants comme modules isolés implémentant interface commune (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Séparation des responsabilités : handlers Discovery, Data et Command spécialisés"},
						{"name": "Strategy Pattern", "description": "Chaque plugin implémente sa propre stratégie d'authentification (OAuth, API Key, propriétaire)"},
						{"name": "Adapter Pattern", "description": "Normalisation des données hétérogènes vers format unique compatible mobile legacy"},
						{"name": "Queue Pattern", "description": "Bull Queue pour commandes planifiées avec découplage trigger/exécution"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulant l'accès aux données avec queries centralisées"},
						{"name": "Factory Pattern", "description": "Rate limit calculators spécifiques par fabricant avec règles personnalisées"},
						{"name": "Decorator Pattern", "description": "Interceptors et filters décorant les opérations avec logging et error handling"}
					],
					"decisions": [
						{"decision": "Redis pour Rate Limiting", "reason": "Distribué, persistant, sliding window précis, réutilisé pour files Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "On a déjà Redis, UI de monitoring (Bull Board), moins de latence que SQS"},
						{"decision": "AES-256-GCM en Base", "reason": "Simplicité opérationnelle vs Vault dédié, suffisant pour le cas d'usage"}
					],
					"challenges": [
						{"challenge": "APIs Hétérogènes", "solution": "Plugin pattern isole la complexité - chaque plugin parle la 'langue' du fabricant"},
						{"challenge": "Rate Limiting Complexe", "solution": "Configuration par fabricant + sliding window Redis + métriques pour ajustement fin"},
						{"challenge": "Compatibilité Mobile Legacy", "solution": "Adapter pattern normalise les réponses au format attendu par l'app ancienne"},
						{"challenge": "Commandes Planifiées", "solution": "AWS EventBridge → Lambda → Bull Queue avec retry exponentiel et audit"}
					]
				}
			],
			"challenges": [
				{"challenge": "Code Mobile Legacy Problématique (Plus Grand Défi)", "solution": "Rien ne fonctionnait - code sale, sans patterns, erreurs en cascade. J'ai réalisé un debugging complet identifiant 73 erreurs critiques, refactoré le backend pour normaliser les données et minimiser les interventions sur le frontend legacy chaotique"},
				{"challenge": "Remplacer Service Tiers", "solution": "Architecture de plugins a permis l'intégration directe avec les fabricants tout en maintenant la compatibilité mobile"}
			]
		},
		"ragboost": {
			"title": "Ragboost",
			"subtitle": "Plateforme SaaS Multi-Tenant de Chatbots IA",
			"role": "Full Stack Developer | Fondateur",
			"period": "Octobre 2024 - Présent",
			"status": "En Développement (85%)",
			"client": "Projet Personnel",
			"overview": {
				"context": "Le marché des chatbots IA est en croissance, mais les solutions entreprise sont chères pour les PME. Les entreprises font face à des coûts élevés par message et stockage, une complexité technique pour intégrer le RAG, des widgets génériques qui ne représentent pas la marque, un manque de collaboration en équipe, et des données isolées non exploitées. L'opportunité : créer une alternative accessible avec des fonctionnalités avancées pour les entreprises de toutes tailles.",
				"solution": "Développement d'une plateforme SaaS complète qui démocratise l'accès aux chatbots IA avec des prix accessibles, simplifie la création d'assistants sans code, évolue avec une architecture multi-tenant robuste, et monétise avec des plans flexibles via Stripe. La plateforme permet aux entreprises de créer des assistants virtuels contextualisés avec leurs propres documents utilisant la technologie RAG (Retrieval-Augmented Generation), avec un système de collaboration en équipe avec RBAC complet et support de 4 langues.",
				"myRole": "En tant que fondateur et développeur full stack, j'ai conçu et implémenté toute l'architecture du système. Côté backend, j'ai développé Clean Architecture avec Either Monad, Use Case Pattern et Domain Events. Côté frontend, j'ai implémenté TanStack Query avec Optimistic Updates, système d'authentification cross-subdomain, et routage file-based avec TanStack Router. J'ai aussi réalisé tout le design UI/UX et les intégrations avec Stripe, service RAG open source, et système d'emails."
			},
			"stack": {
				"frontend": ["React 19", "TypeScript", "Vite", "TanStack Router", "TanStack Query", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "React Hook Form", "Zod", "i18next", "Recharts", "Axios", "Sonner"],
				"backend": ["Fastify", "TypeScript", "Prisma", "PostgreSQL", "JWT", "Stripe", "Nodemailer", "Swagger", "Zod", "Docker"]
			},
			"subProjects": [
				{
					"title": "Backend API",
					"subtitle": "API REST Multi-Tenant avec Clean Architecture",
					"description": "API REST robuste avec architecture clean, 10 modules de domaine, système de permissions granulaire (RBAC) avec 50+ permissions, intégration Stripe pour billing, et Domain Events pour la communication entre modules.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Clean Architecture", "description": "Séparation en couches : routes → controllers → use-cases → repositories → entities"},
							{"name": "Either Monad", "description": "Gestion fonctionnelle des erreurs avec Either<Error, Success> dans tous les use cases"},
							{"name": "Multi-Tenancy", "description": "Isolation complète des données par tenant via subdomain avec middleware de contexte"},
							{"name": "RBAC Granulaire", "description": "50+ permissions sur 4 niveaux de rôles (owner, admin, curator, user)"},
							{"name": "Domain Events", "description": "Communication asynchrone entre modules pour découplage"},
							{"name": "Webhook Service", "description": "Handlers pour événements Stripe (checkout, subscription, invoice) avec vérification de signature"},
							{"name": "Factory Pattern", "description": "Injection de dépendances manuelle sans container, facile à tester et débugger"},
							{"name": "Zod + OpenAPI", "description": "Validation de schemas avec génération automatique de documentation Swagger"},
							{"name": "JWT Double", "description": "Access token (15min) + refresh token (7j) en cookie httpOnly"},
							{"name": "Rate Limiting", "description": "Protection des endpoints avec limites par IP et utilisateur"},
							{"name": "Intégration RAG", "description": "Connexion avec service open source pour traitement de documents et recherche sémantique"},
							{"name": "Système d'Invitations", "description": "Invitations par email avec tracking, expiration et rôles attribuables"},
							{"name": "Abonnement avec Addons", "description": "Système flexible de plans Stripe avec addons modulaires (sièges supplémentaires, stockage, appels API)"},
							{"name": "Billing Complet", "description": "Checkout sessions, portail client, factures, proration, périodes d'essai, annulation"}
						]
					},
					"testing": [
						{"type": "Tests Unitaires", "description": "60+ fichiers de tests unitaires pour use cases et domain logic", "tools": "Node.js Test Runner, In-Memory Repositories", "coverage": "Use cases complets"},
						{"type": "Tests E2E", "description": "40+ fichiers de tests end-to-end pour controllers et flux complets", "tools": "Node.js Test Runner, Prisma Test Environment, Supertest", "coverage": "Controllers critiques"}
					],
					"metrics": {
						"linesOfCode": "~52 000",
						"files": "200+",
						"modules": "10",
						"entities": "17"
					},
					"patterns": [
						{"name": "Either Monad Pattern", "description": "Either<L, R> avec left() pour erreurs et right() pour succès - erreurs type-safe"},
						{"name": "Use Case Pattern", "description": "Chaque opération métier dans une classe isolée avec execute() retournant Either"},
						{"name": "Factory Pattern", "description": "makeXxxUseCase() pour DI manuelle - zéro magie, tree-shakeable, debug facile"},
						{"name": "Controller Pattern", "description": "HTTP handlers qui convertissent Either en status codes appropriés"},
						{"name": "Repository Pattern", "description": "Abstraction d'accès aux données avec Prisma - in-memory pour les tests"},
						{"name": "Provider Pattern", "description": "Services externes (email, payment, RAG) avec interface + implémentation"}
					],
					"decisions": [
						{"decision": "Fastify vs Express vs NestJS", "reason": "2x plus rapide qu'Express, validation de schema native, système de plugins modulaire"},
						{"decision": "Either Monad vs throw/catch", "reason": "Erreurs type-safe, flux explicite, controller sait exactement quelles erreurs attendre"},
						{"decision": "Factory Pattern vs DI Container", "reason": "Zéro magie, tree-shakeable, TypeScript pur sans decorators, facile à tester"},
						{"decision": "PostgreSQL + Prisma vs MongoDB", "reason": "Conformité ACID, relations complexes, type-safety, migrations, RLS natif"}
					],
					"challenges": [
						{"challenge": "Isolation Multi-Tenant", "solution": "Middleware injecte le contexte du tenant dans toutes les queries via header X-Tenant-Subdomain"},
						{"challenge": "50+ Permissions Granulaires", "solution": "Matrice roles → permissions, CheckPermissionUseCase réutilisé dans tous les use cases"},
						{"challenge": "Webhook Stripe avec Raw Body", "solution": "Middleware customisé pour préserver le raw body avant le bodyParser Fastify"},
						{"challenge": "Tests E2E Isolés", "solution": "Prisma test environment avec base isolée, helpers pour générer des données uniques"}
					]
				},
				{
					"title": "Frontend Dashboard",
					"subtitle": "SPA React 19 avec Multi-Tenant via Subdomain",
					"description": "Dashboard administratif SPA avec React 19 et TanStack Router. Système d'authentification cross-subdomain via cookies, cache sophistiqué avec TanStack Query, internationalisation en 4 langues, et 31 composants shadcn/ui.",
					"features": {
						"frontend": [
							{"name": "Multi-Tenant via Subdomain", "description": "Détection automatique du tenant via hostname (tenant1.ragboost.app)"},
							{"name": "Auth Cross-Subdomain", "description": "Cookies partagés entre subdomains via Domain=.ragboost.app"},
							{"name": "TanStack Query Cache", "description": "staleTime, gcTime, refetchOnMount/WindowFocus configurés par query"},
							{"name": "Optimistic Updates", "description": "onMutate → snapshot → rollback avec feedback instantané"},
							{"name": "File-Based Routing", "description": "TanStack Router avec type-safety complet et beforeLoad pour guards"},
							{"name": "Axios Interceptors", "description": "Refresh token automatique, retry avec exponential backoff, error handling i18n"},
							{"name": "RBAC Frontend", "description": "useCurrentUserRole() avec canManageTeam, canEditChatbots, etc."},
							{"name": "Formulaires Validés", "description": "React Hook Form + Zod avec schemas partagés frontend/backend"},
							{"name": "Design System", "description": "31 composants shadcn/ui + Radix UI avec Tailwind CSS 4"},
							{"name": "i18n Complet", "description": "4 langues (PT, EN, FR, ES) avec namespaces lazy-loaded"},
							{"name": "Dashboard Analytics", "description": "Graphiques avec Recharts pour métriques d'utilisation"},
							{"name": "Team Management", "description": "Invitations, rôles, suppression de membres avec optimistic updates"},
							{"name": "Gestion d'Abonnement", "description": "Affichage du plan actuel, addons, utilisation, upgrade/downgrade avec Stripe Customer Portal"},
							{"name": "Sélecteur d'Addons", "description": "Interface pour ajouter/supprimer addons (sièges, stockage, appels API) avec aperçu du prix"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~19 500",
						"files": "206",
						"components": "88",
						"hooks": "7+",
						"pages": "15+"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "useChatbots, useTeamMembers, useAuth encapsulant la logique de données"},
						{"name": "Optimistic Updates Pattern", "description": "onMutate pour snapshot, onError pour rollback, onSuccess pour invalidate"},
						{"name": "Provider Pattern", "description": "AuthProvider, TenantProvider pour état global"},
						{"name": "API Queries Layer", "description": "Séparation en /api/queries avec barrel exports par feature"},
						{"name": "Subdomain Detection", "description": "getCurrentSubdomain() détecte le tenant en dev (lvh.me) et prod"},
						{"name": "Interceptor Pattern", "description": "Axios interceptors pour refresh token et retry automatique"}
					],
					"decisions": [
						{"decision": "React 19 SPA vs Next.js", "reason": "Dashboard n'a pas besoin de SSR, Vite HMR instantané, builds 10x plus rapides"},
						{"decision": "TanStack Query vs Redux", "reason": "Cache automatique, mutations avec optimistic updates, moins de boilerplate"},
						{"decision": "TanStack Router vs React Router", "reason": "Type-safety complet, file-based routing, beforeLoad pour guards"},
						{"decision": "Cookie Auth vs localStorage", "reason": "Partage cross-subdomain impossible avec localStorage"}
					],
					"challenges": [
						{"challenge": "Auth Cross-Subdomain", "solution": "Cookie avec Domain=.localhost (dev) / .ragboost.app (prod) partagé entre tenants"},
						{"challenge": "Refresh Token Transparent", "solution": "Interceptor détecte 401, appelle /refresh-token, retente la requête originale"},
						{"challenge": "State Management Complexe", "solution": "TanStack Query pour server state, useCurrentTenant() pour contexte, zéro Redux"},
						{"challenge": "Détection Subdomain Multi-Environnement", "solution": "Support pour lvh.me (dev), localhost, et multisaas.app (prod) avec même logique"}
					]
				}
			],
			"challenges": [
				{"challenge": "Architecture SaaS Multi-Tenant Complète", "solution": "Tenancy basée sur subdomain avec isolation des données, RBAC granulaire, billing intégré, et Domain Events pour découplage"},
				{"challenge": "Auth Cross-Subdomain Sécurisée", "solution": "JWT en cookies avec Domain wildcard, refresh token automatique, logout sélectif du cache"}
			]
		},
		"va-beauty": {
			"title": "VA Beauty",
			"subtitle": "Site Vitrine & Système de Réservation",
			"role": "Full Stack Developer | UI/UX Designer",
			"period": "Mai - Août 2025",
			"status": "En Production",
			"client": "VA Beauty",
			"overview": {
				"context": "VA Beauty est un institut de beauté boutique à Aubagne, France, spécialisé dans les soins du visage haut de gamme et la micropigmentation. La propriétaire avait besoin d'une présence digitale reflétant la qualité premium de ses services. Le problème : aucune présence en ligne, rendez-vous manuels par téléphone/WhatsApp, pas de portfolio visuel pour montrer les résultats, et gestion manuelle des services et tarifs.",
				"solution": "Développement d'un site vitrine professionnel complet avec : (1) Landing page premium avec sections services, galerie avant/après et témoignages ; (2) Système de réservation intégré à Cal.com avec calendrier en temps réel et paiement Stripe ; (3) Galerie dynamique supportant images, avant/après et vidéos réseaux sociaux ; (4) Blog géré via Sanity CMS pour contenu marketing ; (5) Panneau d'administration pour la gestion des services et galerie sans connaissances techniques.",
				"myRole": "J'ai travaillé en tant que Full Stack Developer et UI/UX Designer, créant tout le design d'interface de zéro et implémentant la solution complète. J'ai développé l'architecture avec Next.js 15 et React 19, intégré plusieurs services externes (Supabase, Cal.com, Stripe, Cloudinary, Sanity), et construit le panneau d'administration pour la gestion autonome du contenu."
			},
			"stack": {
				"frontend": ["Next.js 15", "React 19", "TypeScript", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "Lucide React", "react-day-picker", "class-variance-authority"],
				"backend": ["Supabase (PostgreSQL + Auth + RLS)", "Stripe", "Cal.com", "Cloudinary", "Sanity CMS", "Vercel"]
			},
			"subProjects": [
				{
					"title": "Site Vitrine & Booking",
					"subtitle": "Plateforme Complète de Réservation en Ligne",
					"description": "Site vitrine professionnel avec système de réservation intégré. J'ai créé tout le design UI/UX et implémenté landing page premium, catalogue de services, galerie dynamique, blog, et flux complet de réservation avec paiement.",
					"features": {
						"frontend": [
							{"name": "Landing Page Premium", "description": "Hero avec dégradé, indicateurs de confiance (500+ clients, 5★), sections services et témoignages"},
							{"name": "Catalogue de Services", "description": "Grille avec 3 catégories (Sourcils, Lèvres, Soins), combos/packs avec tarifs"},
							{"name": "Galerie Avant/Après", "description": "Filtre par catégorie, types de médias (images, avant/après, vidéos), modal plein écran"},
							{"name": "Flux de Réservation Multi-Étapes", "description": "4 étapes : sélection service → date/heure → informations → confirmation/paiement"},
							{"name": "Calendrier Cal.com", "description": "Widget intégré avec disponibilité en temps réel et timezone automatique"},
							{"name": "Vidéos Intégrées", "description": "Support Instagram, YouTube et TikTok avec embed responsive"},
							{"name": "Blog Intégré", "description": "Articles gérés via Sanity CMS avec SEO optimisé"},
							{"name": "Design Responsive", "description": "Mobile-first avec typographie Sora et système de couleurs avec dégradés"}
						],
						"backend": [
							{"name": "Auth Supabase", "description": "Authentification avec vérification admin via table admin_accounts"},
							{"name": "Row Level Security", "description": "Politiques RLS pour la protection des données PostgreSQL"},
							{"name": "Intégration Stripe", "description": "Paiements avec Connected Accounts et webhooks bidirectionnels"},
							{"name": "Intégration Cal.com", "description": "API pour disponibilité, création de réservations et synchronisation"},
							{"name": "Upload Cloudinary", "description": "Optimisation automatique des images, transformations à la volée, CDN global"},
							{"name": "Sanity CMS", "description": "Studio personnalisable pour gestion de blog avec queries GROQ"},
							{"name": "Routes API Protégées", "description": "Endpoints pour booking, gallery, admin avec validation et gestion d'erreurs"},
							{"name": "Middleware de Protection", "description": "Next.js Middleware protégeant les routes /admin et /studio"}
						]
					},
					"metrics": {
						"linesOfCode": "~30.135",
						"files": "188",
						"components": "57",
						"pages": "32 routes API"
					},
					"patterns": [
						{"name": "App Router Pattern", "description": "Route groups, layouts imbriqués, loading states avec Next.js 15"},
						{"name": "Server/Client Components", "description": "Server Components pour data fetching, Client pour interactivité"},
						{"name": "Multi-Step Form Pattern", "description": "État centralisé avec étapes progressives et validation par étape"},
						{"name": "Provider Pattern", "description": "AuthProvider + SupabaseProvider pour état global d'authentification"},
						{"name": "Middleware Protection", "description": "Vérification admin à l'edge avant chargement des pages protégées"},
						{"name": "API Route Pattern", "description": "Logique backend isolée avec validation et gestion d'erreurs cohérente"}
					],
					"decisions": [
						{"decision": "Next.js 15 + React 19", "reason": "Server Components pour performance, App Router pour organisation, Turbopack pour builds rapides"},
						{"decision": "Supabase vs Firebase", "reason": "PostgreSQL réel avec SQL, Row Level Security natif, auth intégré, open source, tarifs abordables"},
						{"decision": "Cal.com vs Calendly", "reason": "Open source, API flexible, intégration Stripe native, personnalisation complète, sans branding imposé"},
						{"decision": "Cloudinary vs S3", "reason": "Optimisation automatique des images, transformations à la volée, CDN global inclus, tier gratuit généreux"},
						{"decision": "Sanity vs Contentful", "reason": "Studio personnalisable, langage de requête GROQ puissant, collaboration temps réel, tier gratuit généreux"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste pas dépendance, personnalisation totale, accessibilité via Radix, bundle plus petit, Tailwind natif"}
					],
					"challenges": [
						{"challenge": "Intégration Cal.com + Stripe", "solution": "Stripe Connected Account, webhooks bidirectionnels (Cal → App, Stripe → App), endpoints de diagnostic pour debug"},
						{"challenge": "Galerie Multi-Médias", "solution": "Schéma flexible avec type discriminator, composant MediaModal détectant le type, embed vidéo responsive"},
						{"challenge": "Contrôle d'Accès Admin", "solution": "Table admin_accounts avec permissions JSONB, flag is_active, super-admin fallback, politiques RLS"},
						{"challenge": "SEO pour Services Dynamiques", "solution": "generateMetadata dans chaque page, données structurées JSON-LD, sitemap dynamique, alt text requis"},
						{"challenge": "Performance avec Beaucoup d'Images", "solution": "Next.js Image avec lazy loading, Cloudinary pour optimisation, placeholder blur, sizes responsive"}
					]
				}
			],
			"challenges": [
				{"challenge": "Multiples Intégrations Externes", "solution": "Architecture modulaire avec providers séparés pour chaque service (Supabase, Cal.com, Stripe, Cloudinary, Sanity), webhooks robustes avec retry"},
				{"challenge": "Flux de Réservation Complexe", "solution": "Formulaire multi-étapes avec état centralisé, validation progressive, intégration seamless entre Cal.com et Stripe"}
			]
		}
	}
}
