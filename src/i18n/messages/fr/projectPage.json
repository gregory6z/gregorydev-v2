{
	"backToProjects": "Retour aux projets",
	"visitProject": "Visiter le projet",
	"role": "Rôle",
	"period": "Période",
	"status": "Statut",
	"client": "Client",
	"overview": {
		"title": "Aperçu",
		"context": "Contexte",
		"solution": "Solution",
		"myRole": "Mon Rôle"
	},
	"stack": {
		"title": "Stack Technique",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Fonctionnalités"
	},
	"challenges": {
		"title": "Défis & Solutions"
	},
	"metrics": {
		"title": "Métriques",
		"linesOfCode": "Lignes de Code",
		"files": "Fichiers",
		"modules": "Modules",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Composants",
		"hooks": "Hooks",
		"pages": "Pages"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Décisions Techniques",
		"decision": "Décision",
		"reason": "Justification"
	},
	"gallery": {
		"title": "Galerie"
	},
	"subProjects": "Projets",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Écosystème IA pour le Secteur de la Construction",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Avril 2025 - Présent",
			"status": "En Production",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse est une startup française qui révolutionne le secteur de la construction et de la rénovation énergétique grâce à l'IA Générative. Le problème : les professionnels du bâtiment doivent vérifier la conformité avec plus de 300 réglementations techniques françaises (DTU, normes NF, Eurocodes, etc.), un processus manuel chronophage et sujet aux erreurs. La solution : un assistant IA spécifiquement formé sur ces réglementations, répondant instantanément aux questions techniques en citant les sources officielles.",
				"solution": "L'écosystème se compose de trois composants internes pour que l'équipe La Bonne Réponse gère ses clients : (1) LBR-API - API REST multi-tenant robuste gérant les widgets de chat, l'authentification double (utilisateurs et widgets), les intégrations avec Stripe/AWS/Brevo, et le contrôle qualité automatisé ; (2) IA Factory - Back Office Admin où l'équipe configure les chatbots, génère des widgets personnalisés, gère les bases de connaissances et surveille les conversations ; (3) Portail Utilisateur - où les professionnels du bâtiment accèdent à l'assistant IA avec historique des conversations et gestion des abonnements. Le lien externe redirige vers le site institutionnel de l'entreprise.",
				"myRole": "J'ai occupé le rôle de Lead Front End et UI/UX Designer, responsable de toute l'architecture et du développement front-end des deux plateformes (BO et Portail). J'ai créé tout le design d'interface et l'expérience utilisateur, pris des décisions techniques sur le stack et les patterns de code. J'ai également collaboré activement au développement de l'API backend avec l'équipe House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Outil RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robuste créée par l'équipe House of Coding utilisant NestJS, spécialisée dans la gestion de widgets de chat avec IA. J'ai collaboré en implémentant les appels API du dashboard, l'intégration avec l'outil RAG et l'upload de documents sur S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Intégration RAG", "description": "Connexion avec outil de Retrieval-Augmented Generation pour réponses basées sur documents"},
							{"name": "Multi-Tenancy", "description": "Isolation complète des données par tenant avec JWT validé"},
							{"name": "Authentification Double", "description": "JWT séparé pour utilisateurs (admin, portail) et widgets embarqués"},
							{"name": "CORS Dynamique", "description": "Validation d'origine basée sur widget integrations en base"},
							{"name": "Gestion des Widgets", "description": "Configurations visuelles (4 couleurs), logo, messages, Google Analytics"},
							{"name": "Système de Références", "description": "Upload de documents, URLs autorisées/bloquées, crawling automatique"},
							{"name": "Contrôle Qualité", "description": "Points de vérification avec questions/réponses, validation automatique via IA"},
							{"name": "Intégration Stripe", "description": "Webhooks avec validation de signature, gestion clients par tenant"},
							{"name": "Upload S3", "description": "URLs présignées pour téléchargement sécurisé avec limite de taille"},
							{"name": "Rate Limiting", "description": "Throttler personnalisé avec 100 req/min par IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importation en lot d'utilisateurs avec validation et transaction"},
							{"name": "Swagger Automatique", "description": "Documentation OpenAPI générée via décorateurs NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "Repositories TypeORM pour abstraction d'accès aux données"},
						{"name": "DTO Pattern", "description": "101 DTOs avec class-validator pour validation d'entrée"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard pour contrôle d'accès"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext pour injection de contexte"},
						{"name": "Service Layer", "description": "Logique métier isolée des controllers"},
						{"name": "Module Pattern", "description": "37 modules NestJS pour organisation des features"}
					],
					"decisions": [
						{"decision": "Outil RAG", "reason": "Système pour Retrieval-Augmented Generation, choisi pour la flexibilité et le contrôle sur le pipeline IA"},
						{"decision": "JWT Double (Utilisateurs + Widgets)", "reason": "Widgets embarqués sur sites externes nécessitent authentification propre, sans exposer credentials utilisateurs"},
						{"decision": "CORS Dynamique via Base", "reason": "Chaque widget peut être embarqué sur plusieurs domaines, impossible de configurer CORS statique"},
						{"decision": "URLs Présignées pour S3", "reason": "Téléchargements sécurisés sans exposer credentials AWS, expiration configurable"},
						{"decision": "TypeORM plutôt que Prisma", "reason": "Meilleure intégration NestJS, support décorateurs, performance pour queries complexes"}
					],
					"challenges": [
						{"challenge": "CORS Dynamique pour Widgets", "solution": "Query en base pour valider origine à chaque requête, cache mémoire pour performance"},
						{"challenge": "Webhook Stripe avec Raw Body", "solution": "Middleware personnalisé pour préserver raw body avant bodyParser NestJS"},
						{"challenge": "Import en Lot d'Utilisateurs", "solution": "Parsing CSV/Excel avec fast-csv, validation en lot, insert avec transaction et rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plateforme de Gestion de Chatbots IA",
					"description": "Dashboard administratif enterprise-grade. J'ai créé le design UI/UX, design system et toute l'architecture des composants. J'ai développé les formulaires multi-étapes, tables avancées, gestion des widgets, système de références et toutes les autres fonctionnalités sauf les modules utilisateurs, entreprises et QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administratif", "description": "Interface complète pour la gestion de la plateforme avec métriques"},
							{"name": "Formulaire Multi-Étapes", "description": "Création de widget en 7 étapes avec validation Zod par étape"},
							{"name": "Éditeur par Sections", "description": "Accordion avec sections enregistrables indépendamment via PATCH"},
							{"name": "Widget Configurator", "description": "Prévisualisation en temps réel des personnalisations du chatbot"},
							{"name": "DataTable Composée", "description": "Tables avec TanStack Table : tri, filtres, pagination, sélection batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documents avec react-dropzone"},
							{"name": "Système de QC", "description": "Contrôle qualité avec import CSV/Excel de points de vérification"},
							{"name": "Click Prompts Editor", "description": "Interface pour créer des prompts pré-configurés cliquables"},
							{"name": "Gestion Multi-tenant", "description": "Administration des utilisateurs, entreprises et permissions par rôle"},
							{"name": "Système de Referentials", "description": "Surveillance du crawler avec dernière exécution et détection des changements"},
							{"name": "Cache Invalidation", "description": "Fonction centrale invalidant les queries liées en cascade"},
							{"name": "Historique des Conversations", "description": "Visualisation des conversations utilisateurs avec rendu markdown"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals comme compositions de sous-composants"},
						{"name": "Custom Hooks", "description": "~40 hooks pour logique réutilisable (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextes pour état global des formulaires multi-étapes"},
						{"name": "Optimistic Updates", "description": "React Query avec mutations optimistes pour UX réactive"},
						{"name": "Adapter Pattern", "description": "Transformation données API vers format UI"},
						{"name": "Feature-based Structure", "description": "Organisation par features : /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context pour état UI (formulaires), React Query pour état serveur"},
						{"decision": "Accordion pour édition", "reason": "Permet sauvegarder sections indépendamment sans bloquer l'utilisateur"}
					],
					"challenges": [
						{"challenge": "Formulaire de 7 Étapes", "solution": "Context pour état global, validation Zod par étape, hasStepErrors() pour feedback visuel"},
						{"challenge": "Upload avec Prévisualisation", "solution": "FileReader pour prévisualisation locale immédiate, état séparé pour preview vs saved"},
						{"challenge": "Édition par Sections", "solution": "Accordion avec bouton Save par section, PATCH pour updates partiels, track changes"},
						{"challenge": "Cache Invalidation en Cascade", "solution": "Fonction refetchAllWidgetData() invalidant queries liées dans le bon ordre"}
					]
				},
				{
					"title": "Portail Utilisateur",
					"subtitle": "Portail Web avec Widget de Chat Intégré",
					"description": "Application complète construite de zéro. J'ai implémenté authentification robuste, refresh automatique de tokens, intégration Stripe, widget de chat en iframe isolé et refonte complète de la version Webflow.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automatique", "description": "Refresh JWT 10 minutes avant expiration, replanification continue"},
							{"name": "Widget en Iframe", "description": "Isolation complète CSS/JS avec sandbox, communication via postMessage"},
							{"name": "Intégration Stripe", "description": "Pricing table intégrée, vérification de statut, billing portal"},
							{"name": "Système d'Authentification", "description": "Connexion, inscription, activation de compte, reset de mot de passe"},
							{"name": "Support B2B et B2C", "description": "Logique de souscription différenciée par type de tenant"},
							{"name": "Gestion des Conversations", "description": "Sidebar avec liste de conversations, créer nouvelle, continuer existante"},
							{"name": "Pages de Présentation", "description": "URLs dynamiques par nom pour démos sans authentification"},
							{"name": "Gestion de Compte", "description": "Modifier profil, titre professionnel, secteur, changer mot de passe"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Décodage JWT + setTimeout pour refresh proactif"},
						{"name": "Iframe Isolation", "description": "Widget en sandbox avec communication via postMessage"},
						{"name": "Route Guards", "description": "Protection des routes avec vérification authentification et souscription"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations pour logique encapsulée"}
					],
					"decisions": [
						{"decision": "Iframe pour Widget", "reason": "Isolation complète CSS/JS, évite conflits de style avec le portail"},
						{"decision": "Refresh Proactif", "reason": "Refresh 10min avant évite expiration pendant utilisation active"},
						{"decision": "Stripe Pricing Table", "reason": "Composant embarqué élimine besoin d'UI personnalisée pour plans"},
						{"decision": "B2B sans paiement", "reason": "Entreprises B2B ont contrat direct, pas besoin de checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automatique", "solution": "Décoder JWT pour obtenir expiration, setTimeout 10min avant, replanifier après succès"},
						{"challenge": "Widget en Iframe Isolé", "solution": "Sandbox avec allow-scripts allow-same-origin, paramètres via query string, postMessage"},
						{"challenge": "Statut de Souscription", "solution": "Hook useSubscription() avec logique centralisée pour B2B (sans paiement) et B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Écosystème Multi-Plateforme", "solution": "Architecture modulaire avec API partagée entre BO et Portail, permettant évolution indépendante de chaque application"},
				{"challenge": "Authentification pour Contextes Différents", "solution": "Système JWT double : un pour utilisateurs authentifiés (admin/portail) et un pour widgets embarqués sur sites externes"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plateformes de Formation Professionnelle",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Mars 2025 - Présent",
			"status": "En Production",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs est un organisme de formation professionnelle français qui accompagne les apprenants dans leur parcours de développement. Chaque apprenant est accompagné par un tuteur qui valide ses missions et étapes d'apprentissage. Le problème : un suivi pédagogique fragmenté dans des tableurs et emails, sans traçabilité centralisée du progrès, des évaluations manuelles dispersées (PIX, Cléa, soft skills), et une communication tuteur-apprenant sans historique organisé.",
				"solution": "L'écosystème se compose de deux plateformes complémentaires : (1) LINK-Parcours - Dashboard administratif enterprise-grade pour la gestion des sessions de formation, des utilisateurs avec 8 niveaux de rôles, des évaluations de positionnement (PIX, Cléa, soft skills), et le suivi de progression (béabas, missions) ; (2) Tuto-Mission - PWA mobile-first pour l'accompagnement pédagogique en temps réel, où les tuteurs suivent les apprenants via chat avec support média et validation d'étapes.",
				"myRole": "Sur LINK-Parcours, j'ai occupé le rôle de Lead Front End et UI/UX Designer, créant tout le design de l'interface administrative et implémentant le système complet. Sur Tuto-Mission, j'ai implémenté le design reçu via Figma de House of Coding, développant des stratégies de cache avancées pour compenser l'API legacy et créer une expérience fluide."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (équipe House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administratif de Formation",
					"description": "Plateforme administrative complète pour la gestion des sessions de formation, des utilisateurs et des évaluations. J'ai créé tout le design UI/UX et implémenté le système avec un contrôle d'accès basé sur 8 niveaux de rôles, des tables paginées côté serveur, et des formulaires complexes avec validation i18n.",
					"features": {
						"frontend": [
							{"name": "Gestion des Utilisateurs", "description": "CRUD complet avec 8 niveaux de rôles (superAdmin jusqu'à apprenant)"},
							{"name": "Gestion des Sessions", "description": "Création de sessions avec plusieurs jours (session_jours) et participants"},
							{"name": "Évaluation de Positionnement", "description": "Scores PIX, résultats Cléa, soft skills games, entretiens"},
							{"name": "Suivi de Progression", "description": "Béabas et missions avec calcul de pourcentage global"},
							{"name": "Tables Avancées", "description": "TanStack Table avec tri, filtres, pagination côté serveur"},
							{"name": "URL State Management", "description": "Filtres persistés dans l'URL via nuqs pour le partage"},
							{"name": "Formulaires Validés", "description": "React Hook Form + Zod avec messages i18n en français"},
							{"name": "Upload de Photo", "description": "Drag & drop avec preview et gestion de profil"},
							{"name": "Dashboard avec Graphiques", "description": "Visualisations avec Recharts pour les métriques"},
							{"name": "Système de Rôles", "description": "RoleProtectedRoute + useRoleBasedRedirect pour le contrôle d'accès"},
							{"name": "Pré-inscriptions", "description": "Gestion des candidats par session de formation"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 niveaux hiérarchiques avec RoleProtectedRoute et redirection automatique"},
						{"name": "Container/Presenter", "description": "Hooks de données séparés des composants de table"},
						{"name": "URL State Management", "description": "nuqs synchronise filtres/pagination avec les query parameters"},
						{"name": "Schema Validation", "description": "Zod dynamique avec traductions i18n pour les messages d'erreur"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI avec class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Les hooks adaptent la structure API au format UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Productivité accrue, design system intégré, purge automatique"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives accessibles sans styling imposé, contrôle total sur l'apparence"},
						{"decision": "nuqs pour URL state", "reason": "Synchronisation bidirectionnelle automatique, type-safe avec parsers"},
						{"decision": "Pagination Hybride", "reason": "Côté serveur pour users/sessions (grand volume), côté client pour apprenants (filtrage rapide)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (moins de re-renders), intégration native, meilleur TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Niveaux de Rôles", "solution": "Enum UserGroupCode avec codes numériques hiérarchiques, matrice de permissions par route"},
						{"challenge": "Filtres Persistants", "solution": "État dans l'URL via nuqs + location.state pour le contexte de navigation"},
						{"challenge": "Système de Positionnement", "solution": "Composants dédiés par type (PIX, Cléa, soft skills) + hook usePositioning centralisé"},
						{"challenge": "Formulaires Multi-Étapes", "solution": "Tabs organisant les sections, schéma Zod partiel par section, validation à la soumission"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA d'Accompagnement Pédagogique",
					"description": "Application mobile-first pour l'accompagnement pédagogique en temps réel. J'ai implémenté le design reçu via Figma, développant un système de chat avec support média, validation d'étapes, et une stratégie de cache sophistiquée pour compenser l'API legacy.",
					"features": {
						"frontend": [
							{"name": "Système de Chat", "description": "Messages en temps réel tuteur ↔ apprenant avec historique persistant"},
							{"name": "Upload de Médias", "description": "Photos et vidéos pédagogiques avec preview avant envoi"},
							{"name": "Validation d'Étapes", "description": "Le tuteur valide ou demande une reprise avec feedback visuel immédiat"},
							{"name": "Vidéos avec Timestamps", "description": "Lecteur React Player avec timestamps spécifiques par étape"},
							{"name": "Auto-scroll Intelligent", "description": "Hook useScrollToBottom observe les changements et exécute le scroll"},
							{"name": "Token Refresh Automatique", "description": "Refresh JWT 10min avant l'expiration, transparent pour l'utilisateur"},
							{"name": "Multiples Apprenants", "description": "Sélection automatique si le tuteur en a 1, page de sélection si N"},
							{"name": "Messages de Pédagogie", "description": "Messages automatiques du système avec stylisation différenciée"},
							{"name": "Optimistic Updates", "description": "Les messages apparaissent instantanément avant la confirmation du serveur"},
							{"name": "Cache Performant", "description": "Stale-while-revalidate pour une navigation zéro-latence"},
							{"name": "Internationalisation", "description": "Système multi-langue avec react-i18next pour le support de différentes langues"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centralise la logique d'authentification avec variables globales"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulent la logique de données"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo par type de message"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observe les dépendances pour l'auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrappe les requêtes avec JWT et retry de token"},
						{"name": "Optimistic Updates", "description": "React Query avec mutations optimistes et rollback automatique"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automatique, mutations avec optimistic updates, moins de boilerplate"},
						{"decision": "CSS Pur", "reason": "Projet mobile-first petit, performance sans runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT en cookie pour la sécurité, données utilisateur en localStorage pour un accès rapide"},
						{"decision": "Upload Direct via API", "reason": "Architecture plus simple, le backend contrôle les validations"}
					],
					"challenges": [
						{"challenge": "API Legacy Lente", "solution": "Cache sophistiqué : staleTime 5-10min, gcTime 30min, placeholderData pour UX instantanée"},
						{"challenge": "Refresh de Token Transparent", "solution": "Timer 10min avant expiration + handleTokenExpiration global pour erreurs 401"},
						{"challenge": "Upload avec Preview", "solution": "URL.createObjectURL() pour preview local, envoi séparé de texte et média"},
						{"challenge": "Scroll Automatique en Chat", "solution": "Hook customisé observe [messages, isLoading] et exécute scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Deux Plateformes Complémentaires", "solution": "Architecture cohérente avec React Query dans les deux, patterns réutilisables"},
				{"challenge": "API PHP Legacy Partagée", "solution": "Stratégies de cache côté frontend pour créer une expérience premium sans modifier le backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Couche d'Abstraction pour Appareils IoT",
			"role": "Backend Developer",
			"period": "Novembre 2024 - Présent",
			"status": "En Développement",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "Airwell est une entreprise de climatisation proposant des appareils IoT (climatiseurs, thermostats, capteurs) contrôlés via application mobile. Pour connecter les appareils de plusieurs fabricants, l'entreprise utilisait un service tiers comme intermédiaire. Le problème : coûts récurrents de licence par appareil, vendor lock-in, latence supplémentaire, et impossibilité de personnaliser sans dépendre du fournisseur.",
				"solution": "Actuellement l'entreprise utilise une API externe tierce pour connecter les appareils, générant des coûts mensuels élevés. L'IoT Router est une couche d'abstraction qui se connecte directement aux APIs des fabricants d'appareils, normalise les différents formats en une API unifiée, maintient la compatibilité avec le format attendu par le mobile legacy, et permet d'ajouter de nouveaux fabricants via un système de plugins. La solution va éliminer ces coûts et donner une indépendance technologique totale à l'entreprise.",
				"myRole": "J'ai repris un projet initié par un collègue d'Amiltone et réalisé un refactoring massif, définissant les bonnes pratiques et adaptant l'architecture pour scaler. J'ai conçu l'architecture de plugins pour plusieurs fabricants, développé un système de rate limiting distribué avec Redis, et intégré AWS Lambda pour les commandes planifiées. J'ai également fait des interventions sur l'API server standard d'Airwell pour intégrer l'IoT Router, et réalisé un debugging complet de l'app mobile React Native qui ne fonctionnait pas - identifiant les problèmes et envoyant des rapports à l'équipe."
			},
			"stack": {
				"frontend": ["React Native (debugging + rapports pour équipe Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Système de Plugins Multi-Fabricant + Commandes Planifiées",
					"description": "Couche d'abstraction avec architecture de plugins pour l'intégration avec plusieurs fabricants IoT. Chaque fabricant est un module isolé implémentant une interface commune. Inclut système de commandes planifiées via AWS Lambda + Bull Queue avec retry automatique.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Système extensible où chaque fabricant est un plugin isolé implémentant IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Découverte automatique des appareils par utilisateur et fabricant avec extraction de métadonnées"},
							{"name": "Data Handler", "description": "Lecture de statut, mesures (température, humidité, CO2) avec normalisation des unités"},
							{"name": "Command Handler", "description": "Exécution de commandes (on/off, ajustement température) avec retry automatique"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue pour commandes planifiées avec retry exponentiel"},
							{"name": "OAuth 2.0 Flow", "description": "Flux d'authentification complet avec refresh automatique des tokens chiffrés"},
							{"name": "Rate Limiting", "description": "Algorithme sliding window dans Redis avec règles personnalisées par fabricant"},
							{"name": "Adapter Pattern", "description": "Transformation des données du format fabricant vers format normalisé compatible mobile"},
							{"name": "Configuration as Code", "description": "Configuration des partenaires et appareils via YAML validé par JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulant l'accès aux données avec queries optimisées"},
							{"name": "Interceptors & Guards", "description": "Logging structuré et gestion d'erreurs cohérente dans toute l'application"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricants comme modules isolés implémentant interface commune (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Séparation des responsabilités : handlers Discovery, Data et Command spécialisés"},
						{"name": "Strategy Pattern", "description": "Chaque plugin implémente sa propre stratégie d'authentification (OAuth, API Key, propriétaire)"},
						{"name": "Adapter Pattern", "description": "Normalisation des données hétérogènes vers format unique compatible mobile legacy"},
						{"name": "Queue Pattern", "description": "Bull Queue pour commandes planifiées avec découplage trigger/exécution"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulant l'accès aux données avec queries centralisées"},
						{"name": "Factory Pattern", "description": "Rate limit calculators spécifiques par fabricant avec règles personnalisées"},
						{"name": "Decorator Pattern", "description": "Interceptors et filters décorant les opérations avec logging et error handling"}
					],
					"decisions": [
						{"decision": "Redis pour Rate Limiting", "reason": "Distribué, persistant, sliding window précis, réutilisé pour files Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "On a déjà Redis, UI de monitoring (Bull Board), moins de latence que SQS"},
						{"decision": "AES-256-GCM en Base", "reason": "Simplicité opérationnelle vs Vault dédié, suffisant pour le cas d'usage"}
					],
					"challenges": [
						{"challenge": "APIs Hétérogènes", "solution": "Plugin pattern isole la complexité - chaque plugin parle la 'langue' du fabricant"},
						{"challenge": "Rate Limiting Complexe", "solution": "Configuration par fabricant + sliding window Redis + métriques pour ajustement fin"},
						{"challenge": "Compatibilité Mobile Legacy", "solution": "Adapter pattern normalise les réponses au format attendu par l'app ancienne"},
						{"challenge": "Commandes Planifiées", "solution": "AWS EventBridge → Lambda → Bull Queue avec retry exponentiel et audit"}
					]
				}
			],
			"challenges": [
				{"challenge": "Code Mobile Legacy Problématique (Plus Grand Défi)", "solution": "Rien ne fonctionnait - code sale, sans patterns, erreurs en cascade. J'ai réalisé un debugging complet identifiant 73 erreurs critiques, refactoré le backend pour normaliser les données et minimiser les interventions sur le frontend legacy chaotique"},
				{"challenge": "Remplacer Service Tiers", "solution": "Architecture de plugins a permis l'intégration directe avec les fabricants tout en maintenant la compatibilité mobile"}
			]
		}
	}
}
