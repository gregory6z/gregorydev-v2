{
	"backToProjects": "Voltar aos projetos",
	"visitProject": "Visitar projeto",
	"role": "Função",
	"period": "Período",
	"status": "Status",
	"client": "Cliente",
	"overview": {
		"title": "Visão Geral",
		"context": "Contexto",
		"solution": "Solução",
		"myRole": "Meu Papel"
	},
	"stack": {
		"title": "Stack Técnica",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Features"
	},
	"challenges": {
		"title": "Desafios & Soluções",
		"challenge": "Desafio",
		"solution": "Solução"
	},
	"metrics": {
		"title": "Métricas",
		"linesOfCode": "Linhas de Código",
		"files": "Arquivos",
		"modules": "Módulos",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Componentes",
		"hooks": "Hooks",
		"pages": "Páginas"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Decisões Técnicas",
		"decision": "Decisão",
		"reason": "Justificativa"
	},
	"gallery": {
		"title": "Galeria"
	},
	"subProjects": "Projetos",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Ecossistema de IA para o setor de construção",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Abril 2025 - Atual",
			"status": "Em Produção",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse é uma startup francesa que revoluciona o setor de construção e renovação energética através de IA Generativa. O problema: profissionais da construção civil precisam verificar conformidade com mais de 300 regulamentações técnicas francesas (DTU, normas NF, Eurocodes, etc.), um processo manual demorado e propenso a erros. A solução: um assistente de IA treinado especificamente nessas regulamentações, que responde perguntas técnicas instantaneamente, citando as fontes oficiais.",
				"solution": "O ecossistema consiste em três componentes internos para que a equipe La Bonne Réponse gerencie seus clientes: (1) LBR-API - API REST multi-tenant robusta que gerencia widgets de chat, autenticação dupla (usuários e widgets), integrações com Stripe/AWS/Brevo, e controle de qualidade automatizado; (2) IA Factory - Back Office Admin onde a equipe configura chatbots, gera widgets personalizados, gerencia bases de conhecimento e monitora conversas; (3) Portal Usuário - onde profissionais da construção acessam o assistente de IA com histórico de conversas e gestão de assinaturas. O link externo direciona ao site institucional da empresa.",
				"myRole": "Atuei como Lead Front End e UI/UX Designer, sendo responsável por toda a arquitetura e desenvolvimento front-end de ambas as plataformas (BO e Portal). Criei todo o design de interface e experiência do usuário, tomei decisões técnicas sobre stack e padrões de código. Também colaborei ativamente no desenvolvimento da API backend junto ao time House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Ferramenta RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robusta criada pela equipe House of Coding usando NestJS, especializada em gerenciamento de widgets de chat com IA. Colaborei implementando as chamadas do dashboard, integração com ferramenta RAG e upload de documentos no S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Integração RAG", "description": "Conexão com ferramenta de Retrieval-Augmented Generation para respostas baseadas em documentos"},
							{"name": "Multi-Tenancy", "description": "Isolamento completo de dados por tenant com JWT validado"},
							{"name": "Autenticação Dupla", "description": "JWT separado para usuários (admin, portal) e widgets embarcados"},
							{"name": "CORS Dinâmico", "description": "Validação de origem baseada em widget integrations no banco"},
							{"name": "Gestão de Widgets", "description": "Configurações visuais (4 cores), logo, mensagens, Google Analytics"},
							{"name": "Sistema de Referências", "description": "Upload de documentos, URLs permitidas/bloqueadas, crawling automático"},
							{"name": "Controle de Qualidade", "description": "Pontos de verificação com perguntas/respostas, validação automática via IA"},
							{"name": "Integração Stripe", "description": "Webhooks com validação de assinatura, gestão de clientes por tenant"},
							{"name": "Upload S3", "description": "Presigned URLs para download seguro com limite de tamanho"},
							{"name": "Rate Limiting", "description": "Throttler customizado com 100 req/min por IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importação em lote de usuários com validação e transaction"},
							{"name": "Swagger Automático", "description": "Documentação OpenAPI gerada via decoradores NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "TypeORM repositories para abstração de acesso a dados"},
						{"name": "DTO Pattern", "description": "101 DTOs com class-validator para validação de entrada"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard para controle de acesso"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext para injeção de contexto"},
						{"name": "Service Layer", "description": "Lógica de negócio isolada dos controllers"},
						{"name": "Module Pattern", "description": "37 módulos NestJS para organização de features"}
					],
					"decisions": [
						{"decision": "Ferramenta RAG", "reason": "Sistema para Retrieval-Augmented Generation, escolhido pela flexibilidade e controle sobre o pipeline de IA"},
						{"decision": "JWT Duplo (Usuários + Widgets)", "reason": "Widgets embarcados em sites externos precisam de autenticação própria, sem expor credenciais de usuários"},
						{"decision": "CORS Dinâmico via Banco", "reason": "Cada widget pode ser embarcado em múltiplos domínios, impossível configurar CORS estático"},
						{"decision": "Presigned URLs para S3", "reason": "Downloads seguros sem expor credenciais AWS, com expiração configurável"},
						{"decision": "TypeORM sobre Prisma", "reason": "Melhor integração com NestJS, suporte a decoradores, e performance para queries complexas"}
					],
					"challenges": [
						{"challenge": "CORS Dinâmico para Widgets", "solution": "Query no banco para validar origem em cada request, cache em memória para performance"},
						{"challenge": "Webhook Stripe com Raw Body", "solution": "Middleware customizado para preservar raw body antes do bodyParser do NestJS"},
						{"challenge": "Import em Lote de Usuários", "solution": "Parsing CSV/Excel com fast-csv, validação em lote, insert com transaction e rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plataforma de Gestão de Chatbots IA",
					"description": "Dashboard administrativo enterprise-grade. Criei o design UI/UX, design system e toda estrutura de componentes. Desenvolvi formulários multi-step, tabelas avançadas, gestão de widgets, sistema de referências e todas as demais funcionalidades exceto módulos de usuários, empresas e QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administrativo", "description": "Interface completa para gestão da plataforma com métricas"},
							{"name": "Formulário Multi-Step", "description": "Criação de widget em 7 passos com validação Zod por etapa"},
							{"name": "Editor por Seções", "description": "Accordion com seções salváveis independentemente via PATCH"},
							{"name": "Widget Configurator", "description": "Preview em tempo real das customizações do chatbot"},
							{"name": "DataTable Composição", "description": "Tabelas com TanStack Table: sorting, filtros, paginação, seleção batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documentos com react-dropzone"},
							{"name": "Sistema de QC", "description": "Controle de qualidade com import CSV/Excel de pontos de verificação"},
							{"name": "Click Prompts Editor", "description": "Interface para criar prompts pré-configurados clicáveis"},
							{"name": "Gestão Multi-tenant", "description": "Administração de usuários, empresas e permissões por role"},
							{"name": "Sistema de Referentials", "description": "Monitoramento de crawler com última execução e detecção de mudanças"},
							{"name": "Cache Invalidation", "description": "Função central que invalida queries relacionadas em cascata"},
							{"name": "Histórico de Conversas", "description": "Visualização de conversas dos usuários com markdown rendering"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals como composições de sub-componentes"},
						{"name": "Custom Hooks", "description": "~40 hooks para lógica reutilizável (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextos para estado global de formulários multi-step"},
						{"name": "Optimistic Updates", "description": "React Query com mutações otimistas para UX responsiva"},
						{"name": "Adapter Pattern", "description": "Transformação de dados API para formato de UI"},
						{"name": "Feature-based Structure", "description": "Organização por features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context para estado de UI (formulários), React Query para estado de servidor"},
						{"decision": "Accordion para edição", "reason": "Permite salvar seções independentemente sem bloquear o usuário"}
					],
					"challenges": [
						{"challenge": "Formulário de 7 Passos", "solution": "Context para estado global, validação Zod por step, hasStepErrors() para feedback visual"},
						{"challenge": "Upload com Preview", "solution": "FileReader para preview local imediato, estado separado para preview vs saved"},
						{"challenge": "Edição por Seções", "solution": "Accordion com botão Save por seção, PATCH para updates parciais, track changes"},
						{"challenge": "Cache Invalidation em Cascata", "solution": "Função refetchAllWidgetData() que invalida queries relacionadas na ordem correta"}
					]
				},
				{
					"title": "Portal Usuário",
					"subtitle": "Portal Web com Widget de Chat Integrado",
					"description": "Aplicação completa criada do zero. Implementei autenticação robusta, refresh automático de tokens, integração Stripe, widget de chat em iframe isolado e refatoração completa da versão Webflow legada.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10 minutos antes da expiração, reagendamento contínuo"},
							{"name": "Widget em Iframe", "description": "Isolamento completo CSS/JS com sandbox, comunicação via postMessage"},
							{"name": "Integração Stripe", "description": "Pricing table embarcada, verificação de status, billing portal"},
							{"name": "Sistema de Autenticação", "description": "Login, registro, ativação de conta, reset de senha com tokens"},
							{"name": "Suporte B2B e B2C", "description": "Lógica de subscrição diferenciada por tipo de tenant"},
							{"name": "Gestão de Conversas", "description": "Sidebar com lista de conversas, criar nova, continuar existente"},
							{"name": "Páginas de Apresentação", "description": "URLs dinâmicas por nome para demos sem autenticação"},
							{"name": "Gestão de Conta", "description": "Editar perfil, título profissional, setor, alterar senha com validação robusta"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Decodificação JWT + setTimeout para refresh proativo"},
						{"name": "Iframe Isolation", "description": "Widget em sandbox com comunicação via postMessage"},
						{"name": "Route Guards", "description": "Proteção de rotas com verificação de autenticação e subscrição"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations para lógica encapsulada"}
					],
					"decisions": [
						{"decision": "Iframe para Widget", "reason": "Isolamento completo de CSS/JS, evita conflitos de estilo com o portal"},
						{"decision": "Refresh Proativo", "reason": "Refresh 10min antes evita expiração durante uso ativo"},
						{"decision": "Stripe Pricing Table", "reason": "Componente embarcado elimina necessidade de UI customizada para planos"},
						{"decision": "B2B sem pagamento", "reason": "Empresas B2B têm contrato direto, não precisam de checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automático", "solution": "Decodificar JWT para obter expiração, setTimeout 10min antes, reagendar após sucesso"},
						{"challenge": "Widget em Iframe Isolado", "solution": "Sandbox com allow-scripts allow-same-origin, parâmetros via query string, postMessage"},
						{"challenge": "Status de Subscrição", "solution": "Hook useSubscription() com lógica centralizada para B2B (sem pagamento) e B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Ecossistema Multi-Plataforma", "solution": "Arquitetura modular com API compartilhada entre BO e Portal, permitindo evolução independente de cada aplicação"},
				{"challenge": "Autenticação para Contextos Diferentes", "solution": "Sistema de JWT duplo: um para usuários autenticados (admin/portal) e outro para widgets embarcados em sites externos"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plataformas de Formação Profissional",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Março 2025 - Atual",
			"status": "Em Produção",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs é um organismo de formação profissional francês que acompanha aprendizes (apprenants) em seu percurso de desenvolvimento. Cada apprenant é acompanhado por um tuteur que valida suas missões e etapas de aprendizagem. O problema: acompanhamento pedagógico fragmentado em planilhas e emails, sem rastreabilidade centralizada do progresso, avaliações manuais dispersas (PIX, Cléa, soft skills), e comunicação tutor-apprenant sem histórico organizado.",
				"solution": "O ecossistema consiste em duas plataformas complementares: (1) LINK-Parcours - Dashboard administrativo enterprise-grade para gestão de sessões de formação, usuários com 8 níveis de roles, avaliações de posicionamento (PIX, Cléa, soft skills), e tracking de progresso (béabas, missions); (2) Tuto-Mission - PWA mobile-first para acompanhamento pedagógico em tempo real, onde tutores monitoram apprenants através de chat com suporte a mídia e validação de etapas.",
				"myRole": "No LINK-Parcours, atuei como Lead Front End e UI/UX Designer, criando todo o design da interface administrativa e implementando o sistema completo. No Tuto-Mission, implementei o design recebido via Figma da House of Coding, desenvolvendo estratégias avançadas de cache para compensar API legada e criar experiência fluida."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (equipe House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administrativo de Formação",
					"description": "Plataforma administrativa completa para gestão de sessões de formação, usuários e avaliações. Criei todo o design UI/UX e implementei o sistema com controle de acesso baseado em 8 níveis de roles, tabelas paginadas server-side, e formulários complexos com validação i18n.",
					"features": {
						"frontend": [
							{"name": "Gestão de Usuários", "description": "CRUD completo com 8 níveis de roles (superAdmin até apprenant)"},
							{"name": "Gestão de Sessions", "description": "Criação de sessões com múltiplos dias (session_jours) e participantes"},
							{"name": "Avaliação de Posicionamento", "description": "Scores PIX, résultats Cléa, soft skills games, entretiens"},
							{"name": "Tracking de Progresso", "description": "Béabas e missions com cálculo de percentagem global"},
							{"name": "Tabelas Avançadas", "description": "TanStack Table com sorting, filtros, paginação server-side"},
							{"name": "URL State Management", "description": "Filtros persistidos na URL via nuqs para compartilhamento"},
							{"name": "Formulários Validados", "description": "React Hook Form + Zod com mensagens i18n em francês"},
							{"name": "Upload de Foto", "description": "Drag & drop com preview e gestão de perfil"},
							{"name": "Dashboard com Gráficos", "description": "Visualizações com Recharts para métricas"},
							{"name": "Sistema de Roles", "description": "RoleProtectedRoute + useRoleBasedRedirect para controle de acesso"},
							{"name": "Pré-inscrições", "description": "Gestão de candidatos por sessão de formação"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 níveis hierárquicos com RoleProtectedRoute e redirecionamento automático"},
						{"name": "Container/Presenter", "description": "Hooks de dados separados dos componentes de tabela"},
						{"name": "URL State Management", "description": "nuqs sincroniza filtros/paginação com query parameters"},
						{"name": "Schema Validation", "description": "Zod dinâmico com traduções i18n para mensagens de erro"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI com class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adaptam estrutura da API para formato de UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Produtividade aumentada, design system integrado, purge automático"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives acessíveis sem styling imposto, controle total sobre aparência"},
						{"decision": "nuqs para URL state", "reason": "Sincronização bidirecional automática, type-safe com parsers"},
						{"decision": "Paginação Híbrida", "reason": "Server-side para users/sessions (volume grande), client-side para apprenants (filtagem rápida)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (menos re-renders), integração nativa, melhor TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Níveis de Roles", "solution": "Enum UserGroupCode com códigos numéricos hierárquicos, matriz de permissões por rota"},
						{"challenge": "Filtros Persistentes", "solution": "Estado na URL via nuqs + location.state para contexto de navegação"},
						{"challenge": "Sistema de Posicionamento", "solution": "Componentes dedicados por tipo (PIX, Cléa, soft skills) + hook usePositioning centralizado"},
						{"challenge": "Formulários Multi-Etapas", "solution": "Tabs organizando seções, schema Zod parcial por seção, validação na submissão"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA de Acompanhamento Pedagógico",
					"description": "Aplicação mobile-first para acompanhamento pedagógico em tempo real. Implementei o design recebido via Figma, desenvolvendo sistema de chat com suporte a mídia, validação de etapas, e estratégia de cache sofisticada para compensar API legada.",
					"features": {
						"frontend": [
							{"name": "Sistema de Chat", "description": "Mensagens em tempo real tutor ↔ apprenant com histórico persistente"},
							{"name": "Upload de Mídia", "description": "Fotos e vídeos pedagógicos com preview antes do envio"},
							{"name": "Validação de Etapas", "description": "Tuteur valida ou solicita refação com feedback visual imediato"},
							{"name": "Vídeos com Timestamps", "description": "Player React Player com timestamps específicos por etapa"},
							{"name": "Auto-scroll Inteligente", "description": "Hook useScrollToBottom observa mudanças e executa scroll"},
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10min antes da expiração, transparente ao usuário"},
							{"name": "Múltiplos Apprenants", "description": "Seleção automática se tuteur tem 1, página de seleção se N"},
							{"name": "Mensagens de Pedagogia", "description": "Mensagens automáticas do sistema com estilização diferenciada"},
							{"name": "Optimistic Updates", "description": "Mensagens aparecem instantaneamente antes da confirmação do servidor"},
							{"name": "Cache Performático", "description": "Stale-while-revalidate para navegação zero-latency"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centraliza lógica de autenticação com variáveis globais"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulam lógica de dados"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo por tipo de mensagem"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observa dependências para auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrapa requisições com JWT e retry de token"},
						{"name": "Optimistic Updates", "description": "React Query com mutações otimistas e rollback automático"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automático, mutations com optimistic updates, menos boilerplate"},
						{"decision": "CSS Puro", "reason": "Projeto mobile-first pequeno, performance sem runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT em cookie para segurança, dados do usuário em localStorage para acesso rápido"},
						{"decision": "Upload Direto via API", "reason": "Arquitetura mais simples, backend controla validações"}
					],
					"challenges": [
						{"challenge": "API Legada Lenta", "solution": "Cache sofisticado: staleTime 5-10min, gcTime 30min, placeholderData para UX instantânea"},
						{"challenge": "Refresh de Token Transparente", "solution": "Timer 10min antes da expiração + handleTokenExpiration global para erros 401"},
						{"challenge": "Upload com Preview", "solution": "URL.createObjectURL() para preview local, envio separado de texto e mídia"},
						{"challenge": "Scroll Automático em Chat", "solution": "Hook customizado observa [messages, isLoading] e executa scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Duas Plataformas Complementares", "solution": "Arquitetura consistente com React Query em ambas, patterns reutilizáveis"},
				{"challenge": "API PHP Legada Compartilhada", "solution": "Estratégias de cache no frontend para criar experiência premium sem modificar backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Camada de Abstração para Dispositivos IoT",
			"role": "Backend Developer",
			"period": "Novembro 2024 - Atual",
			"status": "Em Desenvolvimento",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "A Airwell é uma empresa de climatização que oferece dispositivos IoT (ar-condicionado, termostatos, sensores) controlados via aplicativo mobile. Para conectar esses dispositivos de múltiplos fabricantes, a empresa utilizava um serviço terceirizado que atuava como intermediário. O problema: custos recorrentes de licenciamento por dispositivo, vendor lock-in, latência adicional, e impossibilidade de customizar sem depender do fornecedor.",
				"solution": "Atualmente a empresa utiliza uma API externa terceirizada para conectar os dispositivos, gerando altos custos mensais. O IoT Router é uma camada de abstração que conecta diretamente às APIs dos fabricantes de dispositivos, normaliza os diferentes formatos para uma API unificada, mantém compatibilidade com o formato esperado pelo mobile legado, e escala para suportar novos fabricantes via sistema de plugins. A solução vai eliminar esses custos e dar independência tecnológica total à empresa.",
				"myRole": "Assumi o projeto iniciado por um colega da Amiltone e realizei uma refatoração massiva, definindo boas práticas e adaptando a arquitetura para escalar. Projetei a arquitetura de plugins para múltiplos fabricantes, desenvolvi sistema de rate limiting distribuído com Redis, e integrei AWS Lambda para comandos agendados. Também fiz intervenções na API server padrão da Airwell para integrar o IoT Router, e realizei debugging completo do app mobile React Native que não estava funcionando - identificando problemas e enviando relatórios para a equipe."
			},
			"stack": {
				"frontend": ["React Native (debugging + relatórios para equipe Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Sistema de Plugins Multi-Fabricante + Comandos Agendados",
					"description": "Camada de abstração com arquitetura de plugins para integração com múltiplos fabricantes de IoT. Cada fabricante é um módulo isolado que implementa uma interface comum. Inclui sistema de comandos agendados via AWS Lambda + Bull Queue com retry automático.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Sistema extensível onde cada fabricante é um plugin isolado implementando IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Descoberta automática de dispositivos do usuário em cada fabricante com extração de metadados"},
							{"name": "Data Handler", "description": "Leitura de status, medições (temperatura, humidade, CO2) com normalização de unidades"},
							{"name": "Command Handler", "description": "Execução de comandos (ligar/desligar, ajustar temperatura) com retry automático"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue para comandos agendados com retry exponencial"},
							{"name": "OAuth 2.0 Flow", "description": "Fluxo completo de autenticação com refresh automático de tokens criptografados"},
							{"name": "Rate Limiting", "description": "Sliding window algorithm no Redis com regras customizadas por fabricante"},
							{"name": "Adapter Pattern", "description": "Transformação de dados do formato do fabricante para formato normalizado compatível com mobile"},
							{"name": "Configuration as Code", "description": "Configuração de parceiros e dispositivos via YAML validado por JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulando acesso a dados com queries otimizadas"},
							{"name": "Interceptors & Guards", "description": "Logging estruturado e tratamento de erros consistente em toda aplicação"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricantes como módulos isolados implementando interface comum (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separação de responsabilidades: Discovery, Data e Command handlers especializados"},
						{"name": "Strategy Pattern", "description": "Cada plugin implementa sua própria estratégia de autenticação (OAuth, API Key, proprietária)"},
						{"name": "Adapter Pattern", "description": "Normalização de dados heterogêneos para formato único compatível com mobile legado"},
						{"name": "Queue Pattern", "description": "Bull Queue para comandos agendados com desacoplamento trigger/execução"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulando acesso a dados com queries centralizadas"},
						{"name": "Factory Pattern", "description": "Rate limit calculators específicos por fabricante com regras customizadas"},
						{"name": "Decorator Pattern", "description": "Interceptors e filters decorando operações com logging e error handling"}
					],
					"decisions": [
						{"decision": "Redis para Rate Limiting", "reason": "Distribuído, persistente, sliding window preciso, reutilizado para filas Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Já temos Redis, UI de monitoramento (Bull Board), menos latência que SQS"},
						{"decision": "AES-256-GCM no Banco", "reason": "Simplicidade operacional vs Vault dedicado, suficiente para o caso de uso"}
					],
					"challenges": [
						{"challenge": "APIs Heterogêneas", "solution": "Plugin pattern isola complexidade - cada plugin fala a 'língua' do fabricante"},
						{"challenge": "Rate Limiting Complexo", "solution": "Configuração por fabricante + sliding window no Redis + métricas para ajuste fino"},
						{"challenge": "Compatibilidade Mobile Legado", "solution": "Adapter pattern normaliza respostas no formato esperado pelo app antigo"},
						{"challenge": "Comandos Agendados", "solution": "AWS EventBridge → Lambda → Bull Queue com retry exponencial e auditoria"}
					]
				}
			],
			"challenges": [
				{"challenge": "Código Mobile Legado Problemático (Maior Desafio)", "solution": "Nada funcionava - código sujo, sem padrões, erros em cascata. Realizei debugging completo identificando 73 erros críticos, refatorei o backend para normalizar dados e minimizar intervenções no frontend legado caótico"},
				{"challenge": "Substituir Serviço Terceirizado", "solution": "Arquitetura de plugins permitiu integração direta com fabricantes mantendo compatibilidade mobile"}
			]
		}
	}
}
