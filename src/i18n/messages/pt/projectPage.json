{
	"backToProjects": "Voltar aos projetos",
	"visitProject": "Visitar projeto",
	"role": "Função",
	"period": "Período",
	"status": "Status",
	"client": "Cliente",
	"overview": {
		"title": "Visão Geral",
		"context": "Contexto",
		"solution": "Solução",
		"myRole": "Meu Papel"
	},
	"stack": {
		"title": "Stack Técnica",
		"frontend": "Frontend",
		"backend": "Backend"
	},
	"features": {
		"title": "Features"
	},
	"challenges": {
		"title": "Desafios & Soluções",
		"challenge": "Desafio",
		"solution": "Solução"
	},
	"metrics": {
		"title": "Métricas",
		"linesOfCode": "Linhas de Código",
		"files": "Arquivos",
		"modules": "Módulos",
		"entities": "Entities",
		"dtos": "DTOs",
		"components": "Componentes",
		"hooks": "Hooks",
		"pages": "Páginas"
	},
	"patterns": {
		"title": "Design Patterns"
	},
	"decisions": {
		"title": "Decisões Técnicas",
		"decision": "Decisão",
		"reason": "Justificativa"
	},
	"testing": {
		"title": "Estratégia de Testes",
		"type": "Tipo",
		"tools": "Ferramentas",
		"coverage": "Cobertura"
	},
	"gallery": {
		"title": "Galeria"
	},
	"subProjects": "Projetos",
	"projects": {
		"la-bonne-reponse": {
			"title": "La Bonne Réponse",
			"subtitle": "Ecossistema de IA para o setor de construção",
			"role": "Full Stack Developer | Lead Front End | UI/UX Designer",
			"period": "Abril 2025 - Atual",
			"status": "Em Produção",
			"client": "La Bonne Réponse (via House of Coding / Amiltone)",
			"overview": {
				"context": "La Bonne Réponse é uma startup francesa que revoluciona o setor de construção e renovação energética através de IA Generativa. O problema: profissionais da construção civil precisam verificar conformidade com mais de 300 regulamentações técnicas francesas (DTU, normas NF, Eurocodes, etc.), um processo manual demorado e propenso a erros. A solução: um assistente de IA treinado especificamente nessas regulamentações, que responde perguntas técnicas instantaneamente, citando as fontes oficiais.",
				"solution": "O ecossistema consiste em três componentes internos para que a equipe La Bonne Réponse gerencie seus clientes: (1) LBR-API - API REST multi-tenant robusta que gerencia widgets de chat, autenticação dupla (usuários e widgets), integrações com Stripe/AWS/Brevo, e controle de qualidade automatizado; (2) IA Factory - Back Office Admin onde a equipe configura chatbots, gera widgets personalizados, gerencia bases de conhecimento e monitora conversas; (3) Portal Usuário - onde profissionais da construção acessam o assistente de IA com histórico de conversas e gestão de assinaturas. O link externo direciona ao site institucional da empresa.",
				"myRole": "Atuei como Lead Front End e UI/UX Designer, sendo responsável por toda a arquitetura e desenvolvimento front-end de ambas as plataformas (BO e Portal). Criei todo o design de interface e experiência do usuário, tomei decisões técnicas sobre stack e padrões de código. Também colaborei ativamente no desenvolvimento da API backend junto ao time House of Coding."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "Lucide React", "react-i18next", "Sonner", "react-dropzone"],
				"backend": ["NestJS", "TypeScript", "TypeORM", "MySQL", "JWT/Passport", "bcrypt", "Stripe", "AWS S3", "Brevo", "Ferramenta RAG", "Winston", "Swagger", "Docker"]
			},
			"subProjects": [
				{
					"title": "LBR-API",
					"subtitle": "API REST Multi-Tenant",
					"description": "API REST robusta criada pela equipe House of Coding usando NestJS, especializada em gerenciamento de widgets de chat com IA. Colaborei implementando as chamadas do dashboard, integração com ferramenta RAG e upload de documentos no S3.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Integração RAG", "description": "Conexão com ferramenta de Retrieval-Augmented Generation para respostas baseadas em documentos"},
							{"name": "Multi-Tenancy", "description": "Isolamento completo de dados por tenant com JWT validado"},
							{"name": "Autenticação Dupla", "description": "JWT separado para usuários (admin, portal) e widgets embarcados"},
							{"name": "CORS Dinâmico", "description": "Validação de origem baseada em widget integrations no banco"},
							{"name": "Gestão de Widgets", "description": "Configurações visuais (4 cores), logo, mensagens, Google Analytics"},
							{"name": "Sistema de Referências", "description": "Upload de documentos, URLs permitidas/bloqueadas, crawling automático"},
							{"name": "Controle de Qualidade", "description": "Pontos de verificação com perguntas/respostas, validação automática via IA"},
							{"name": "Integração Stripe", "description": "Webhooks com validação de assinatura, gestão de clientes por tenant"},
							{"name": "Upload S3", "description": "Presigned URLs para download seguro com limite de tamanho"},
							{"name": "Rate Limiting", "description": "Throttler customizado com 100 req/min por IP + user_id"},
							{"name": "Import CSV/Excel", "description": "Importação em lote de usuários com validação e transaction"},
							{"name": "Swagger Automático", "description": "Documentação OpenAPI gerada via decoradores NestJS"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000-20.000",
						"files": "373",
						"modules": "37",
						"entities": "26",
						"dtos": "101"
					},
					"patterns": [
						{"name": "Repository Pattern", "description": "TypeORM repositories para abstração de acesso a dados"},
						{"name": "DTO Pattern", "description": "101 DTOs com class-validator para validação de entrada"},
						{"name": "Guard Pattern", "description": "JwtAuthGuard, WidgetAuthGuard, RolesGuard para controle de acesso"},
						{"name": "Decorator Pattern", "description": "@CurrentUser, @Roles, @WidgetContext para injeção de contexto"},
						{"name": "Service Layer", "description": "Lógica de negócio isolada dos controllers"},
						{"name": "Module Pattern", "description": "37 módulos NestJS para organização de features"}
					],
					"decisions": [
						{"decision": "Ferramenta RAG", "reason": "Sistema para Retrieval-Augmented Generation, escolhido pela flexibilidade e controle sobre o pipeline de IA"},
						{"decision": "JWT Duplo (Usuários + Widgets)", "reason": "Widgets embarcados em sites externos precisam de autenticação própria, sem expor credenciais de usuários"},
						{"decision": "CORS Dinâmico via Banco", "reason": "Cada widget pode ser embarcado em múltiplos domínios, impossível configurar CORS estático"},
						{"decision": "Presigned URLs para S3", "reason": "Downloads seguros sem expor credenciais AWS, com expiração configurável"},
						{"decision": "TypeORM sobre Prisma", "reason": "Melhor integração com NestJS, suporte a decoradores, e performance para queries complexas"}
					],
					"challenges": [
						{"challenge": "CORS Dinâmico para Widgets", "solution": "Query no banco para validar origem em cada request, cache em memória para performance"},
						{"challenge": "Webhook Stripe com Raw Body", "solution": "Middleware customizado para preservar raw body antes do bodyParser do NestJS"},
						{"challenge": "Import em Lote de Usuários", "solution": "Parsing CSV/Excel com fast-csv, validação em lote, insert com transaction e rollback"}
					]
				},
				{
					"title": "IA Factory - Back Office Admin",
					"subtitle": "Plataforma de Gestão de Chatbots IA",
					"description": "Dashboard administrativo enterprise-grade. Criei o design UI/UX, design system e toda estrutura de componentes. Desenvolvi formulários multi-step, tabelas avançadas, gestão de widgets, sistema de referências e todas as demais funcionalidades exceto módulos de usuários, empresas e QA.",
					"features": {
						"frontend": [
							{"name": "Dashboard Administrativo", "description": "Interface completa para gestão da plataforma com métricas"},
							{"name": "Formulário Multi-Step", "description": "Criação de widget em 7 passos com validação Zod por etapa"},
							{"name": "Editor por Seções", "description": "Accordion com seções salváveis independentemente via PATCH"},
							{"name": "Widget Configurator", "description": "Preview em tempo real das customizações do chatbot"},
							{"name": "DataTable Composição", "description": "Tabelas com TanStack Table: sorting, filtros, paginação, seleção batch"},
							{"name": "Knowledge Base UI", "description": "Upload drag-and-drop de documentos com react-dropzone"},
							{"name": "Sistema de QC", "description": "Controle de qualidade com import CSV/Excel de pontos de verificação"},
							{"name": "Click Prompts Editor", "description": "Interface para criar prompts pré-configurados clicáveis"},
							{"name": "Gestão Multi-tenant", "description": "Administração de usuários, empresas e permissões por role"},
							{"name": "Sistema de Referentials", "description": "Monitoramento de crawler com última execução e detecção de mudanças"},
							{"name": "Cache Invalidation", "description": "Função central que invalida queries relacionadas em cascata"},
							{"name": "Histórico de Conversas", "description": "Visualização de conversas dos usuários com markdown rendering"},
							{"name": "Internacionalização", "description": "Sistema multi-idioma com react-i18next para suporte a diferentes línguas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~32.000",
						"files": "293",
						"components": "~150",
						"hooks": "~40",
						"pages": "25+"
					},
					"patterns": [
						{"name": "Compound Components", "description": "DataTable, Forms, Modals como composições de sub-componentes"},
						{"name": "Custom Hooks", "description": "~40 hooks para lógica reutilizável (useWidget, useQualityControl, etc.)"},
						{"name": "Context API", "description": "Contextos para estado global de formulários multi-step"},
						{"name": "Optimistic Updates", "description": "React Query com mutações otimistas para UX responsiva"},
						{"name": "Adapter Pattern", "description": "Transformação de dados API para formato de UI"},
						{"name": "Feature-based Structure", "description": "Organização por features: /widgets, /users, /quality-control"}
					],
					"decisions": [
						{"decision": "Context + React Query", "reason": "Context para estado de UI (formulários), React Query para estado de servidor"},
						{"decision": "Accordion para edição", "reason": "Permite salvar seções independentemente sem bloquear o usuário"}
					],
					"challenges": [
						{"challenge": "Formulário de 7 Passos", "solution": "Context para estado global, validação Zod por step, hasStepErrors() para feedback visual"},
						{"challenge": "Upload com Preview", "solution": "FileReader para preview local imediato, estado separado para preview vs saved"},
						{"challenge": "Edição por Seções", "solution": "Accordion com botão Save por seção, PATCH para updates parciais, track changes"},
						{"challenge": "Cache Invalidation em Cascata", "solution": "Função refetchAllWidgetData() que invalida queries relacionadas na ordem correta"}
					]
				},
				{
					"title": "Portal Usuário",
					"subtitle": "Portal Web com Widget de Chat Integrado",
					"description": "Aplicação completa criada do zero. Implementei autenticação robusta, refresh automático de tokens, integração Stripe, widget de chat em iframe isolado e refatoração completa da versão Webflow legada.",
					"features": {
						"frontend": [
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10 minutos antes da expiração, reagendamento contínuo"},
							{"name": "Widget em Iframe", "description": "Isolamento completo CSS/JS com sandbox, comunicação via postMessage"},
							{"name": "Integração Stripe", "description": "Pricing table embarcada, verificação de status, billing portal"},
							{"name": "Sistema de Autenticação", "description": "Login, registro, ativação de conta, reset de senha com tokens"},
							{"name": "Suporte B2B e B2C", "description": "Lógica de subscrição diferenciada por tipo de tenant"},
							{"name": "Gestão de Conversas", "description": "Sidebar com lista de conversas, criar nova, continuar existente"},
							{"name": "Páginas de Apresentação", "description": "URLs dinâmicas por nome para demos sem autenticação"},
							{"name": "Gestão de Conta", "description": "Editar perfil, título profissional, setor, alterar senha com validação robusta"},
							{"name": "Internacionalização", "description": "Sistema multi-idioma com react-i18next para suporte a diferentes línguas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~6.300",
						"files": "75",
						"components": "~35",
						"hooks": "~15",
						"pages": "12"
					},
					"patterns": [
						{"name": "Token Refresh Pattern", "description": "Decodificação JWT + setTimeout para refresh proativo"},
						{"name": "Iframe Isolation", "description": "Widget em sandbox com comunicação via postMessage"},
						{"name": "Route Guards", "description": "Proteção de rotas com verificação de autenticação e subscrição"},
						{"name": "Custom Hooks", "description": "useAuth, useSubscription, useConversations para lógica encapsulada"}
					],
					"decisions": [
						{"decision": "Iframe para Widget", "reason": "Isolamento completo de CSS/JS, evita conflitos de estilo com o portal"},
						{"decision": "Refresh Proativo", "reason": "Refresh 10min antes evita expiração durante uso ativo"},
						{"decision": "Stripe Pricing Table", "reason": "Componente embarcado elimina necessidade de UI customizada para planos"},
						{"decision": "B2B sem pagamento", "reason": "Empresas B2B têm contrato direto, não precisam de checkout"}
					],
					"challenges": [
						{"challenge": "Token Refresh Automático", "solution": "Decodificar JWT para obter expiração, setTimeout 10min antes, reagendar após sucesso"},
						{"challenge": "Widget em Iframe Isolado", "solution": "Sandbox com allow-scripts allow-same-origin, parâmetros via query string, postMessage"},
						{"challenge": "Status de Subscrição", "solution": "Hook useSubscription() com lógica centralizada para B2B (sem pagamento) e B2C"}
					]
				}
			],
			"challenges": [
				{"challenge": "Ecossistema Multi-Plataforma", "solution": "Arquitetura modular com API compartilhada entre BO e Portal, permitindo evolução independente de cada aplicação"},
				{"challenge": "Autenticação para Contextos Diferentes", "solution": "Sistema de JWT duplo: um para usuários autenticados (admin/portal) e outro para widgets embarcados em sites externos"}
			]
		},
		"les-performeurs": {
			"title": "Les Performeurs",
			"subtitle": "Plataformas de Formação Profissional",
			"role": "Lead Front End Developer | UI/UX Designer",
			"period": "Março 2025 - Atual",
			"status": "Em Produção",
			"client": "Les Performeurs (via House of Coding / Amiltone)",
			"overview": {
				"context": "Les Performeurs é um organismo de formação profissional francês que acompanha aprendizes (apprenants) em seu percurso de desenvolvimento. Cada apprenant é acompanhado por um tuteur que valida suas missões e etapas de aprendizagem. O problema: acompanhamento pedagógico fragmentado em planilhas e emails, sem rastreabilidade centralizada do progresso, avaliações manuais dispersas (PIX, Cléa, soft skills), e comunicação tutor-apprenant sem histórico organizado.",
				"solution": "O ecossistema consiste em duas plataformas complementares: (1) LINK-Parcours - Dashboard administrativo enterprise-grade para gestão de sessões de formação, usuários com 8 níveis de roles, avaliações de posicionamento (PIX, Cléa, soft skills), e tracking de progresso (béabas, missions); (2) Tuto-Mission - PWA mobile-first para acompanhamento pedagógico em tempo real, onde tutores monitoram apprenants através de chat com suporte a mídia e validação de etapas.",
				"myRole": "No LINK-Parcours, atuei como Lead Front End e UI/UX Designer, criando todo o design da interface administrativa e implementando o sistema completo. No Tuto-Mission, implementei o design recebido via Figma da House of Coding, desenvolvendo estratégias avançadas de cache para compensar API legada e criar experiência fluida."
			},
			"stack": {
				"frontend": ["React", "TypeScript", "Vite", "Tailwind CSS", "Radix UI", "shadcn/ui", "TanStack React Query", "TanStack Table", "React Hook Form", "Zod", "React Router", "nuqs", "Lucide React", "react-i18next", "Sonner", "Recharts", "react-dropzone"],
				"backend": ["API REST PHP (equipe House of Coding)"]
			},
			"subProjects": [
				{
					"title": "LINK-Parcours",
					"subtitle": "Dashboard Administrativo de Formação",
					"description": "Plataforma administrativa completa para gestão de sessões de formação, usuários e avaliações. Criei todo o design UI/UX e implementei o sistema com controle de acesso baseado em 8 níveis de roles, tabelas paginadas server-side, e formulários complexos com validação i18n.",
					"features": {
						"frontend": [
							{"name": "Gestão de Usuários", "description": "CRUD completo com 8 níveis de roles (superAdmin até apprenant)"},
							{"name": "Gestão de Sessions", "description": "Criação de sessões com múltiplos dias (session_jours) e participantes"},
							{"name": "Avaliação de Posicionamento", "description": "Scores PIX, résultats Cléa, soft skills games, entretiens"},
							{"name": "Tracking de Progresso", "description": "Béabas e missions com cálculo de percentagem global"},
							{"name": "Tabelas Avançadas", "description": "TanStack Table com sorting, filtros, paginação server-side"},
							{"name": "URL State Management", "description": "Filtros persistidos na URL via nuqs para compartilhamento"},
							{"name": "Formulários Validados", "description": "React Hook Form + Zod com mensagens i18n em francês"},
							{"name": "Upload de Foto", "description": "Drag & drop com preview e gestão de perfil"},
							{"name": "Dashboard com Gráficos", "description": "Visualizações com Recharts para métricas"},
							{"name": "Sistema de Roles", "description": "RoleProtectedRoute + useRoleBasedRedirect para controle de acesso"},
							{"name": "Pré-inscrições", "description": "Gestão de candidatos por sessão de formação"},
							{"name": "Internacionalização", "description": "Sistema multi-idioma com react-i18next para suporte a diferentes línguas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~21.500",
						"files": "200+",
						"components": "26+",
						"hooks": "14",
						"pages": "11"
					},
					"patterns": [
						{"name": "Role-Based Access Control", "description": "8 níveis hierárquicos com RoleProtectedRoute e redirecionamento automático"},
						{"name": "Container/Presenter", "description": "Hooks de dados separados dos componentes de tabela"},
						{"name": "URL State Management", "description": "nuqs sincroniza filtros/paginação com query parameters"},
						{"name": "Schema Validation", "description": "Zod dinâmico com traduções i18n para mensagens de erro"},
						{"name": "Composition Pattern", "description": "shadcn/ui + Radix UI com class-variance-authority"},
						{"name": "Adapter Pattern", "description": "Hooks adaptam estrutura da API para formato de UI"}
					],
					"decisions": [
						{"decision": "Tailwind CSS v4", "reason": "Produtividade aumentada, design system integrado, purge automático"},
						{"decision": "Radix UI + shadcn/ui", "reason": "Primitives acessíveis sem styling imposto, controle total sobre aparência"},
						{"decision": "nuqs para URL state", "reason": "Sincronização bidirecional automática, type-safe com parsers"},
						{"decision": "Paginação Híbrida", "reason": "Server-side para users/sessions (volume grande), client-side para apprenants (filtagem rápida)"},
						{"decision": "React Hook Form + Zod", "reason": "Performance (menos re-renders), integração nativa, melhor TypeScript"}
					],
					"challenges": [
						{"challenge": "8 Níveis de Roles", "solution": "Enum UserGroupCode com códigos numéricos hierárquicos, matriz de permissões por rota"},
						{"challenge": "Filtros Persistentes", "solution": "Estado na URL via nuqs + location.state para contexto de navegação"},
						{"challenge": "Sistema de Posicionamento", "solution": "Componentes dedicados por tipo (PIX, Cléa, soft skills) + hook usePositioning centralizado"},
						{"challenge": "Formulários Multi-Etapas", "solution": "Tabs organizando seções, schema Zod parcial por seção, validação na submissão"}
					]
				},
				{
					"title": "Tuto-Mission",
					"subtitle": "PWA de Acompanhamento Pedagógico",
					"description": "Aplicação mobile-first para acompanhamento pedagógico em tempo real. Implementei o design recebido via Figma, desenvolvendo sistema de chat com suporte a mídia, validação de etapas, e estratégia de cache sofisticada para compensar API legada.",
					"features": {
						"frontend": [
							{"name": "Sistema de Chat", "description": "Mensagens em tempo real tutor ↔ apprenant com histórico persistente"},
							{"name": "Upload de Mídia", "description": "Fotos e vídeos pedagógicos com preview antes do envio"},
							{"name": "Validação de Etapas", "description": "Tuteur valida ou solicita refação com feedback visual imediato"},
							{"name": "Vídeos com Timestamps", "description": "Player React Player com timestamps específicos por etapa"},
							{"name": "Auto-scroll Inteligente", "description": "Hook useScrollToBottom observa mudanças e executa scroll"},
							{"name": "Token Refresh Automático", "description": "Refresh JWT 10min antes da expiração, transparente ao usuário"},
							{"name": "Múltiplos Apprenants", "description": "Seleção automática se tuteur tem 1, página de seleção se N"},
							{"name": "Mensagens de Pedagogia", "description": "Mensagens automáticas do sistema com estilização diferenciada"},
							{"name": "Optimistic Updates", "description": "Mensagens aparecem instantaneamente antes da confirmação do servidor"},
							{"name": "Cache Performático", "description": "Stale-while-revalidate para navegação zero-latency"},
							{"name": "Internacionalização", "description": "Sistema multi-idioma com react-i18next para suporte a diferentes línguas"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~4.200",
						"files": "50+",
						"components": "13",
						"hooks": "5",
						"pages": "6"
					},
					"patterns": [
						{"name": "Provider Pattern", "description": "useAuth centraliza lógica de autenticação com variáveis globais"},
						{"name": "Custom Hook Pattern", "description": "useMessages, useMissions encapsulam lógica de dados"},
						{"name": "Compound Components", "description": "MessageText, MessagePhoto, MessageVideo por tipo de mensagem"},
						{"name": "Observer Pattern", "description": "useScrollToBottom observa dependências para auto-scroll"},
						{"name": "Interceptor Pattern", "description": "interceptFetch wrapa requisições com JWT e retry de token"},
						{"name": "Optimistic Updates", "description": "React Query com mutações otimistas e rollback automático"}
					],
					"decisions": [
						{"decision": "React Query vs Redux", "reason": "Cache automático, mutations com optimistic updates, menos boilerplate"},
						{"decision": "CSS Puro", "reason": "Projeto mobile-first pequeno, performance sem runtime CSS-in-JS"},
						{"decision": "localStorage + Cookies", "reason": "JWT em cookie para segurança, dados do usuário em localStorage para acesso rápido"},
						{"decision": "Upload Direto via API", "reason": "Arquitetura mais simples, backend controla validações"}
					],
					"challenges": [
						{"challenge": "API Legada Lenta", "solution": "Cache sofisticado: staleTime 5-10min, gcTime 30min, placeholderData para UX instantânea"},
						{"challenge": "Refresh de Token Transparente", "solution": "Timer 10min antes da expiração + handleTokenExpiration global para erros 401"},
						{"challenge": "Upload com Preview", "solution": "URL.createObjectURL() para preview local, envio separado de texto e mídia"},
						{"challenge": "Scroll Automático em Chat", "solution": "Hook customizado observa [messages, isLoading] e executa scrollIntoView"}
					]
				}
			],
			"challenges": [
				{"challenge": "Duas Plataformas Complementares", "solution": "Arquitetura consistente com React Query em ambas, patterns reutilizáveis"},
				{"challenge": "API PHP Legada Compartilhada", "solution": "Estratégias de cache no frontend para criar experiência premium sem modificar backend"}
			]
		},
		"airwell-iot-router": {
			"title": "Airwell IoT Router",
			"subtitle": "Camada de Abstração para Dispositivos IoT",
			"role": "Backend Developer",
			"period": "Novembro 2024 - Atual",
			"status": "Em Desenvolvimento",
			"client": "Airwell (via House of Coding / Amiltone)",
			"overview": {
				"context": "A Airwell é uma empresa de climatização que oferece dispositivos IoT (ar-condicionado, termostatos, sensores) controlados via aplicativo mobile. Para conectar esses dispositivos de múltiplos fabricantes, a empresa utilizava um serviço terceirizado que atuava como intermediário. O problema: custos recorrentes de licenciamento por dispositivo, vendor lock-in, latência adicional, e impossibilidade de customizar sem depender do fornecedor.",
				"solution": "Atualmente a empresa utiliza uma API externa terceirizada para conectar os dispositivos, gerando altos custos mensais. O IoT Router é uma camada de abstração que conecta diretamente às APIs dos fabricantes de dispositivos, normaliza os diferentes formatos para uma API unificada, mantém compatibilidade com o formato esperado pelo mobile legado, e escala para suportar novos fabricantes via sistema de plugins. A solução vai eliminar esses custos e dar independência tecnológica total à empresa.",
				"myRole": "Assumi o projeto iniciado por um colega da Amiltone e realizei uma refatoração massiva, definindo boas práticas e adaptando a arquitetura para escalar. Projetei a arquitetura de plugins para múltiplos fabricantes, desenvolvi sistema de rate limiting distribuído com Redis, e integrei AWS Lambda para comandos agendados. Também fiz intervenções na API server padrão da Airwell para integrar o IoT Router, e realizei debugging completo do app mobile React Native que não estava funcionando - identificando problemas e enviando relatórios para a equipe."
			},
			"stack": {
				"frontend": ["React Native (debugging + relatórios para equipe Airwell)"],
				"backend": ["Node.js", "NestJS", "TypeScript", "MySQL", "TypeORM", "Redis", "Bull", "BullMQ", "AWS Lambda", "AWS EventBridge", "OAuth 2.0", "JWT", "AES-256-GCM", "Docker", "Jest", "Swagger", "class-validator"]
			},
			"subProjects": [
				{
					"title": "IoT Router",
					"subtitle": "Sistema de Plugins Multi-Fabricante + Comandos Agendados",
					"description": "Camada de abstração com arquitetura de plugins para integração com múltiplos fabricantes de IoT. Cada fabricante é um módulo isolado que implementa uma interface comum. Inclui sistema de comandos agendados via AWS Lambda + Bull Queue com retry automático.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Plugin Architecture", "description": "Sistema extensível onde cada fabricante é um plugin isolado implementando IPartnerPlugin"},
							{"name": "Discovery Handler", "description": "Descoberta automática de dispositivos do usuário em cada fabricante com extração de metadados"},
							{"name": "Data Handler", "description": "Leitura de status, medições (temperatura, humidade, CO2) com normalização de unidades"},
							{"name": "Command Handler", "description": "Execução de comandos (ligar/desligar, ajustar temperatura) com retry automático"},
							{"name": "Scheduled Commands", "description": "AWS EventBridge + Lambda + Bull Queue para comandos agendados com retry exponencial"},
							{"name": "OAuth 2.0 Flow", "description": "Fluxo completo de autenticação com refresh automático de tokens criptografados"},
							{"name": "Rate Limiting", "description": "Sliding window algorithm no Redis com regras customizadas por fabricante"},
							{"name": "Adapter Pattern", "description": "Transformação de dados do formato do fabricante para formato normalizado compatível com mobile"},
							{"name": "Configuration as Code", "description": "Configuração de parceiros e dispositivos via YAML validado por JSON Schema"},
							{"name": "Entity Loaders", "description": "Repository pattern encapsulando acesso a dados com queries otimizadas"},
							{"name": "Interceptors & Guards", "description": "Logging estruturado e tratamento de erros consistente em toda aplicação"}
						]
					},
					"metrics": {
						"linesOfCode": "~15.000+",
						"files": "181",
						"modules": "12",
						"entities": "14"
					},
					"patterns": [
						{"name": "Plugin Architecture", "description": "Fabricantes como módulos isolados implementando interface comum (Open/Closed Principle)"},
						{"name": "Handler Pattern", "description": "Separação de responsabilidades: Discovery, Data e Command handlers especializados"},
						{"name": "Strategy Pattern", "description": "Cada plugin implementa sua própria estratégia de autenticação (OAuth, API Key, proprietária)"},
						{"name": "Adapter Pattern", "description": "Normalização de dados heterogêneos para formato único compatível com mobile legado"},
						{"name": "Queue Pattern", "description": "Bull Queue para comandos agendados com desacoplamento trigger/execução"},
						{"name": "Repository Pattern", "description": "Entity Loaders encapsulando acesso a dados com queries centralizadas"},
						{"name": "Factory Pattern", "description": "Rate limit calculators específicos por fabricante com regras customizadas"},
						{"name": "Decorator Pattern", "description": "Interceptors e filters decorando operações com logging e error handling"}
					],
					"decisions": [
						{"decision": "Redis para Rate Limiting", "reason": "Distribuído, persistente, sliding window preciso, reutilizado para filas Bull"},
						{"decision": "Bull Queue vs AWS SQS", "reason": "Já temos Redis, UI de monitoramento (Bull Board), menos latência que SQS"},
						{"decision": "AES-256-GCM no Banco", "reason": "Simplicidade operacional vs Vault dedicado, suficiente para o caso de uso"}
					],
					"challenges": [
						{"challenge": "APIs Heterogêneas", "solution": "Plugin pattern isola complexidade - cada plugin fala a 'língua' do fabricante"},
						{"challenge": "Rate Limiting Complexo", "solution": "Configuração por fabricante + sliding window no Redis + métricas para ajuste fino"},
						{"challenge": "Compatibilidade Mobile Legado", "solution": "Adapter pattern normaliza respostas no formato esperado pelo app antigo"},
						{"challenge": "Comandos Agendados", "solution": "AWS EventBridge → Lambda → Bull Queue com retry exponencial e auditoria"}
					]
				}
			],
			"challenges": [
				{"challenge": "Código Mobile Legado Problemático (Maior Desafio)", "solution": "Nada funcionava - código sujo, sem padrões, erros em cascata. Realizei debugging completo identificando 73 erros críticos, refatorei o backend para normalizar dados e minimizar intervenções no frontend legado caótico"},
				{"challenge": "Substituir Serviço Terceirizado", "solution": "Arquitetura de plugins permitiu integração direta com fabricantes mantendo compatibilidade mobile"}
			]
		},
		"ragboost": {
			"title": "Ragboost",
			"subtitle": "Plataforma SaaS Multi-Tenant de Chatbots IA",
			"role": "Full Stack Developer | Founder",
			"period": "Outubro 2024 - Presente",
			"status": "Em Desenvolvimento (85%)",
			"client": "Projeto Próprio",
			"overview": {
				"context": "O mercado de chatbots IA está em crescimento, mas soluções enterprise são caras para PMEs. Empresas enfrentam custos elevados por mensagem e armazenamento, complexidade técnica para integrar RAG, widgets genéricos que não representam a marca, falta de colaboração em equipe, e dados isolados que não são aproveitados. A oportunidade: criar uma alternativa acessível com recursos avançados para empresas de todos os tamanhos.",
				"solution": "Desenvolvimento de uma plataforma SaaS completa que democratiza o acesso a chatbots IA com preços acessíveis, simplifica a criação de assistentes sem código, escala com arquitetura multi-tenant robusta, e monetiza com planos flexíveis via Stripe. A plataforma permite que empresas criem assistentes virtuais contextualizados com base em seus próprios documentos usando tecnologia RAG (Retrieval-Augmented Generation), com sistema de colaboração em equipe com RBAC completo e suporte a 4 idiomas.",
				"myRole": "Como fundador e desenvolvedor full stack, projetei e implementei toda a arquitetura do sistema. No backend, desenvolvi Clean Architecture com Either Monad, Use Case Pattern, e Domain Events. No frontend, implementei TanStack Query com Optimistic Updates, sistema de autenticação cross-subdomain, e roteamento file-based com TanStack Router. Também fiz todo o design UI/UX e as integrações com Stripe, serviço RAG open source, e sistema de emails."
			},
			"stack": {
				"frontend": ["React 19", "TypeScript", "Vite", "TanStack Router", "TanStack Query", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "React Hook Form", "Zod", "i18next", "Recharts", "Axios", "Sonner"],
				"backend": ["Fastify", "TypeScript", "Prisma", "PostgreSQL", "JWT", "Stripe", "Nodemailer", "Swagger", "Zod", "Docker"]
			},
			"subProjects": [
				{
					"title": "Backend API",
					"subtitle": "API REST Multi-Tenant com Clean Architecture",
					"description": "API REST robusta com arquitetura limpa, 10 módulos de domínio, sistema de permissões granular (RBAC) com 50+ permissões, integração com Stripe para billing, e Domain Events para comunicação entre módulos.",
					"features": {
						"frontend": [],
						"backend": [
							{"name": "Clean Architecture", "description": "Separação em camadas: routes → controllers → use-cases → repositories → entities"},
							{"name": "Either Monad", "description": "Tratamento funcional de erros com Either<Error, Success> em todos os use cases"},
							{"name": "Multi-Tenancy", "description": "Isolamento total de dados por tenant via subdomain com middleware de contexto"},
							{"name": "RBAC Granular", "description": "50+ permissões em 4 níveis de roles (owner, admin, curator, user)"},
							{"name": "Domain Events", "description": "Comunicação assíncrona entre módulos para desacoplamento"},
							{"name": "Webhook Service", "description": "Handlers para eventos Stripe (checkout, subscription, invoice) com verificação de assinatura"},
							{"name": "Factory Pattern", "description": "Injeção de dependências manual sem container, fácil de testar e debugar"},
							{"name": "Zod + OpenAPI", "description": "Validação de schemas com geração automática de documentação Swagger"},
							{"name": "JWT Duplo", "description": "Access token (15min) + refresh token (7d) em cookie httpOnly"},
							{"name": "Rate Limiting", "description": "Proteção de endpoints com limites por IP e usuário"},
							{"name": "Integração RAG", "description": "Conexão com serviço open source para processamento de documentos e busca semântica"},
							{"name": "Sistema de Convites", "description": "Envio de convites por email com tracking, expiração e roles atribuíveis"},
							{"name": "Subscription com Addons", "description": "Sistema flexível de planos Stripe com addons modulares (extra seats, storage, API calls)"},
							{"name": "Billing Completo", "description": "Checkout sessions, customer portal, invoices, proration, trial periods, cancellation"}
						]
					},
					"testing": [
						{"type": "Unit Tests", "description": "60+ arquivos de testes unitários para use cases e domain logic", "tools": "Node.js Test Runner, In-Memory Repositories", "coverage": "Use cases completos"},
						{"type": "E2E Tests", "description": "40+ arquivos de testes end-to-end para controllers e fluxos completos", "tools": "Node.js Test Runner, Prisma Test Environment, Supertest", "coverage": "Todas as rotas"}
					],
					"metrics": {
						"linesOfCode": "~52.000",
						"files": "200+",
						"modules": "10",
						"entities": "17"
					},
					"patterns": [
						{"name": "Either Monad Pattern", "description": "Either<L, R> com left() para erros e right() para sucesso - erros são type-safe"},
						{"name": "Use Case Pattern", "description": "Cada operação de negócio em classe isolada com execute() retornando Either"},
						{"name": "Factory Pattern", "description": "makeXxxUseCase() para DI manual - zero magic, tree-shakeable, fácil debug"},
						{"name": "Controller Pattern", "description": "HTTP handlers que convertem Either em status codes apropriados"},
						{"name": "Repository Pattern", "description": "Abstração de acesso a dados com Prisma - in-memory para testes"},
						{"name": "Provider Pattern", "description": "Serviços externos (email, payment, RAG) com interface + implementação"}
					],
					"decisions": [
						{"decision": "Fastify vs Express vs NestJS", "reason": "2x mais rápido que Express, schema validation nativo, plugin system modular"},
						{"decision": "Either Monad vs throw/catch", "reason": "Erros type-safe, fluxo explícito, controller sabe exatamente que erros esperar"},
						{"decision": "Factory Pattern vs DI Container", "reason": "Zero magic, tree-shakeable, TypeScript puro sem decorators, fácil de testar"},
						{"decision": "PostgreSQL + Prisma vs MongoDB", "reason": "ACID compliance, relações complexas, type-safety, migrations, RLS nativo"}
					],
					"challenges": [
						{"challenge": "Isolamento Multi-Tenant", "solution": "Middleware injeta contexto do tenant em todas as queries via header X-Tenant-Subdomain"},
						{"challenge": "50+ Permissões Granulares", "solution": "Matriz de roles → permissions, CheckPermissionUseCase reutilizado em todos os use cases"},
						{"challenge": "Webhook Stripe com Raw Body", "solution": "Middleware customizado para preservar raw body antes do bodyParser do Fastify"},
						{"challenge": "Testes E2E Isolados", "solution": "Prisma test environment com banco isolado, helpers para gerar dados únicos"}
					]
				},
				{
					"title": "Frontend Dashboard",
					"subtitle": "SPA React 19 com Multi-Tenant via Subdomain",
					"description": "Dashboard administrativo SPA com React 19 e TanStack Router. Sistema de autenticação cross-subdomain via cookies, cache sofisticado com TanStack Query, internacionalização em 4 idiomas, e 31 componentes shadcn/ui.",
					"features": {
						"frontend": [
							{"name": "Multi-Tenant via Subdomain", "description": "Detecção automática de tenant via hostname (tenant1.ragboost.app)"},
							{"name": "Auth Cross-Subdomain", "description": "Cookies compartilhados entre subdomains via Domain=.ragboost.app"},
							{"name": "TanStack Query Cache", "description": "staleTime, gcTime, refetchOnMount/WindowFocus configurados por query"},
							{"name": "Optimistic Updates", "description": "onMutate → snapshot → rollback com feedback instantâneo"},
							{"name": "File-Based Routing", "description": "TanStack Router com type-safety completo e beforeLoad para guards"},
							{"name": "Axios Interceptors", "description": "Refresh token automático, retry com exponential backoff, error handling i18n"},
							{"name": "RBAC no Frontend", "description": "useCurrentUserRole() com canManageTeam, canEditChatbots, etc."},
							{"name": "Formulários Validados", "description": "React Hook Form + Zod com schemas compartilhados frontend/backend"},
							{"name": "Design System", "description": "31 componentes shadcn/ui + Radix UI com Tailwind CSS 4"},
							{"name": "i18n Completo", "description": "4 idiomas (PT, EN, FR, ES) com namespaces lazy-loaded"},
							{"name": "Dashboard Analytics", "description": "Gráficos com Recharts para métricas de uso"},
							{"name": "Team Management", "description": "Convites, roles, remoção de membros com optimistic updates"},
							{"name": "Subscription Management", "description": "Visualização de plano atual, addons, usage, upgrade/downgrade com Stripe Customer Portal"},
							{"name": "Addon Selector", "description": "Interface para adicionar/remover addons (seats, storage, API calls) com preview de preço"}
						],
						"backend": []
					},
					"metrics": {
						"linesOfCode": "~19.500",
						"files": "206",
						"components": "88",
						"hooks": "7+",
						"pages": "15+"
					},
					"patterns": [
						{"name": "Custom Hooks Pattern", "description": "useChatbots, useTeamMembers, useAuth encapsulando lógica de dados"},
						{"name": "Optimistic Updates Pattern", "description": "onMutate para snapshot, onError para rollback, onSuccess para invalidate"},
						{"name": "Provider Pattern", "description": "AuthProvider, TenantProvider para estado global"},
						{"name": "API Queries Layer", "description": "Separação em /api/queries com barrel exports por feature"},
						{"name": "Subdomain Detection", "description": "getCurrentSubdomain() detecta tenant em dev (lvh.me) e prod"},
						{"name": "Interceptor Pattern", "description": "Axios interceptors para refresh token e retry automático"}
					],
					"decisions": [
						{"decision": "React 19 SPA vs Next.js", "reason": "Dashboard não precisa de SSR, Vite HMR instantâneo, builds 10x mais rápidos"},
						{"decision": "TanStack Query vs Redux", "reason": "Cache automático, mutations com optimistic updates, menos boilerplate"},
						{"decision": "TanStack Router vs React Router", "reason": "Type-safety completo, file-based routing, beforeLoad para guards"},
						{"decision": "Cookie Auth vs localStorage", "reason": "Compartilhamento cross-subdomain impossível com localStorage"}
					],
					"challenges": [
						{"challenge": "Auth Cross-Subdomain", "solution": "Cookie com Domain=.localhost (dev) / .ragboost.app (prod) compartilhado entre tenants"},
						{"challenge": "Refresh Token Transparente", "solution": "Interceptor detecta 401, chama /refresh-token, retenta request original"},
						{"challenge": "State Management Complexo", "solution": "TanStack Query para server state, useCurrentTenant() para contexto, zero Redux"},
						{"challenge": "Subdomain Detection Multi-Ambiente", "solution": "Suporte a lvh.me (dev), localhost, e multisaas.app (prod) com mesma lógica"}
					]
				}
			],
			"challenges": [
				{"challenge": "Arquitetura SaaS Multi-Tenant Completa", "solution": "Subdomain-based tenancy com isolamento de dados, RBAC granular, billing integrado, e Domain Events para desacoplamento"},
				{"challenge": "Auth Cross-Subdomain Segura", "solution": "JWT em cookies com Domain wildcard, refresh token automático, logout seletivo de cache"}
			]
		},
		"va-beauty": {
			"title": "VA Beauty",
			"subtitle": "Site Vitrine & Sistema de Reservas",
			"role": "Full Stack Developer | UI/UX Designer",
			"period": "Maio - Agosto 2025",
			"status": "Em Produção",
			"client": "VA Beauty",
			"overview": {
				"context": "VA Beauty é um instituto de beleza boutique em Aubagne, França, especializado em tratamentos faciais de alta qualidade e micropigmentação. A proprietária precisava de uma presença digital que refletisse a qualidade premium de seus serviços. O problema: sem presença online, agendamentos manuais por telefone/WhatsApp, sem portfólio visual para mostrar resultados, e gestão manual de serviços e preços.",
				"solution": "Desenvolvimento de um site vitrine profissional completo com: (1) Landing page premium com seções de serviços, galeria antes/depois e depoimentos; (2) Sistema de reservas integrado ao Cal.com com calendário em tempo real e pagamento Stripe; (3) Galeria dinâmica com suporte a imagens, antes/depois e vídeos de redes sociais; (4) Blog gerenciado via Sanity CMS para conteúdo de marketing; (5) Painel administrativo para gestão de serviços e galeria sem conhecimento técnico.",
				"myRole": "Atuei como Full Stack Developer e UI/UX Designer, criando todo o design da interface do zero e implementando a solução completa. Desenvolvi a arquitetura com Next.js 15 e React 19, integrei múltiplos serviços externos (Supabase, Cal.com, Stripe, Cloudinary, Sanity), e construí o painel administrativo para gestão autônoma do conteúdo."
			},
			"stack": {
				"frontend": ["Next.js 15", "React 19", "TypeScript", "Tailwind CSS 4", "shadcn/ui", "Radix UI", "Lucide React", "react-day-picker", "class-variance-authority"],
				"backend": ["Supabase (PostgreSQL + Auth + RLS)", "Stripe", "Cal.com", "Cloudinary", "Sanity CMS", "Vercel"]
			},
			"subProjects": [
				{
					"title": "Site Vitrine & Booking",
					"subtitle": "Plataforma Completa de Reservas Online",
					"description": "Site vitrine profissional com sistema de reservas integrado. Criei todo o design UI/UX e implementei landing page premium, catálogo de serviços, galeria dinâmica, blog, e fluxo completo de reservas com pagamento.",
					"features": {
						"frontend": [
							{"name": "Landing Page Premium", "description": "Hero com gradiente, indicadores de confiança (500+ clientes, 5★), seções de serviços e depoimentos"},
							{"name": "Catálogo de Serviços", "description": "Grid com 3 categorias (Sourcils, Lèvres, Soins), combos/pacotes com preços"},
							{"name": "Galeria Antes/Depois", "description": "Filtro por categoria, tipos de mídia (imagens, antes/depois, vídeos), modal full-screen"},
							{"name": "Fluxo de Reserva Multi-Step", "description": "4 etapas: seleção de serviço → data/hora → informações → confirmação/pagamento"},
							{"name": "Calendário Cal.com", "description": "Widget embarcado com disponibilidade em tempo real e timezone automático"},
							{"name": "Vídeos Embarcados", "description": "Suporte a Instagram, YouTube e TikTok com embed responsivo"},
							{"name": "Blog Integrado", "description": "Artigos gerenciados via Sanity CMS com SEO otimizado"},
							{"name": "Design Responsivo", "description": "Mobile-first com tipografia Sora e sistema de cores com gradientes"}
						],
						"backend": [
							{"name": "Auth Supabase", "description": "Autenticação com verificação de admin via tabela admin_accounts"},
							{"name": "Row Level Security", "description": "Políticas RLS para proteção de dados no PostgreSQL"},
							{"name": "Integração Stripe", "description": "Pagamentos com Connected Accounts e webhooks bidirecionais"},
							{"name": "Integração Cal.com", "description": "API para disponibilidade, criação de bookings e sincronização"},
							{"name": "Upload Cloudinary", "description": "Otimização automática de imagens, transformações on-the-fly, CDN global"},
							{"name": "Sanity CMS", "description": "Studio customizável para gestão de blog com GROQ queries"},
							{"name": "API Routes Protegidas", "description": "Endpoints para booking, gallery, admin com validação e error handling"},
							{"name": "Middleware de Proteção", "description": "Next.js Middleware protegendo rotas /admin e /studio"}
						]
					},
					"metrics": {
						"linesOfCode": "~30.135",
						"files": "188",
						"components": "57",
						"pages": "32 API routes"
					},
					"patterns": [
						{"name": "App Router Pattern", "description": "Route groups, layouts aninhados, loading states com Next.js 15"},
						{"name": "Server/Client Components", "description": "Server Components para data fetching, Client para interatividade"},
						{"name": "Multi-Step Form Pattern", "description": "Estado centralizado com steps progressivos e validação por etapa"},
						{"name": "Provider Pattern", "description": "AuthProvider + SupabaseProvider para estado global de autenticação"},
						{"name": "Middleware Protection", "description": "Verificação de admin no edge antes de carregar páginas protegidas"},
						{"name": "API Route Pattern", "description": "Backend logic isolada com validação e error handling consistente"}
					],
					"decisions": [
						{"decision": "Next.js 15 + React 19", "reason": "Server Components para performance, App Router para organização, Turbopack para builds rápidos"},
						{"decision": "Supabase vs Firebase", "reason": "PostgreSQL real com SQL, Row Level Security nativo, auth integrado, open source, pricing acessível"},
						{"decision": "Cal.com vs Calendly", "reason": "Open source, API flexível, integração Stripe nativa, customização completa, sem branding forçado"},
						{"decision": "Cloudinary vs S3", "reason": "Otimização automática de imagens, transformações on-the-fly, CDN global incluído, free tier generoso"},
						{"decision": "Sanity vs Contentful", "reason": "Studio customizável, GROQ query language poderosa, real-time collaboration, generous free tier"},
						{"decision": "shadcn/ui vs Material UI", "reason": "Copy-paste não dependência, customização total, acessibilidade via Radix, bundle menor, Tailwind nativo"}
					],
					"challenges": [
						{"challenge": "Integração Cal.com + Stripe", "solution": "Stripe Connected Account, webhooks bidirecionais (Cal → App, Stripe → App), endpoints de diagnóstico para debug"},
						{"challenge": "Galeria Multi-Mídia", "solution": "Schema flexível com type discriminator, componente MediaModal detectando tipo, embed responsivo para vídeos"},
						{"challenge": "Admin Access Control", "solution": "Tabela admin_accounts com permissions JSONB, flag is_active, super-admin fallback, RLS policies"},
						{"challenge": "SEO para Serviços Dinâmicos", "solution": "generateMetadata em cada page, structured data JSON-LD, sitemap dinâmico, alt text obrigatório"},
						{"challenge": "Performance com Muitas Imagens", "solution": "Next.js Image com lazy loading, Cloudinary para otimização, placeholder blur, responsive sizes"}
					]
				}
			],
			"challenges": [
				{"challenge": "Múltiplas Integrações Externas", "solution": "Arquitetura modular com providers separados para cada serviço (Supabase, Cal.com, Stripe, Cloudinary, Sanity), webhooks robustos com retry"},
				{"challenge": "Fluxo de Reserva Complexo", "solution": "Multi-step form com estado centralizado, validação progressiva, integração seamless entre Cal.com e Stripe"}
			]
		}
	}
}
